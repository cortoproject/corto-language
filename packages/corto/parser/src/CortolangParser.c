/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : Cortolang.g
 *     -                            On : 2016-06-07 22:03:53
 *     -                for the parser : CortolangParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "CortolangParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pCortolangParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pCortolangParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pCortolangParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pCortolangParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   CortolangParserTokenNames[76+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AMPERSAND",
        (pANTLR3_UINT8) "AMP_EQUAL",
        (pANTLR3_UINT8) "ASTERISK",
        (pANTLR3_UINT8) "CHARACTER",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COLON_EQUAL",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "DEDENT",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DIV_EQUAL",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "DOUBLE_COLON",
        (pANTLR3_UINT8) "EMARK",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "EQUALS",
        (pANTLR3_UINT8) "ESC",
        (pANTLR3_UINT8) "GID",
        (pANTLR3_UINT8) "GREATER_THAN",
        (pANTLR3_UINT8) "GREATER_THAN_EQUAL",
        (pANTLR3_UINT8) "HAT",
        (pANTLR3_UINT8) "HAT_EQUAL",
        (pANTLR3_UINT8) "IMPLICIT_LINE_WHITESPACE",
        (pANTLR3_UINT8) "INDENT",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "KW_AND",
        (pANTLR3_UINT8) "KW_BREAK",
        (pANTLR3_UINT8) "KW_CONTINUE",
        (pANTLR3_UINT8) "KW_DECLARE",
        (pANTLR3_UINT8) "KW_DEFINE",
        (pANTLR3_UINT8) "KW_DESTRUCT",
        (pANTLR3_UINT8) "KW_ELSE",
        (pANTLR3_UINT8) "KW_FALSE",
        (pANTLR3_UINT8) "KW_FOR",
        (pANTLR3_UINT8) "KW_IF",
        (pANTLR3_UINT8) "KW_NOT",
        (pANTLR3_UINT8) "KW_ON",
        (pANTLR3_UINT8) "KW_OR",
        (pANTLR3_UINT8) "KW_SCOPE",
        (pANTLR3_UINT8) "KW_SELF",
        (pANTLR3_UINT8) "KW_SYNCHRONIZED",
        (pANTLR3_UINT8) "KW_TREE",
        (pANTLR3_UINT8) "KW_TRUE",
        (pANTLR3_UINT8) "KW_UPDATE",
        (pANTLR3_UINT8) "KW_WAIT",
        (pANTLR3_UINT8) "KW_WHILE",
        (pANTLR3_UINT8) "LBRACE",
        (pANTLR3_UINT8) "LBRACK",
        (pANTLR3_UINT8) "LEADING_WHITESPACE",
        (pANTLR3_UINT8) "LESS_THAN",
        (pANTLR3_UINT8) "LESS_THAN_EQUAL",
        (pANTLR3_UINT8) "LETTER_UNDERSCORE",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "LSHIFT",
        (pANTLR3_UINT8) "LSHIFT_EQUALS",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "MINUS_EQUAL",
        (pANTLR3_UINT8) "MOD_EQUAL",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "NOT_EQUALS",
        (pANTLR3_UINT8) "PIPE",
        (pANTLR3_UINT8) "PIPE_EQUAL",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "PLUS_EQUAL",
        (pANTLR3_UINT8) "QMARK",
        (pANTLR3_UINT8) "RBRACE",
        (pANTLR3_UINT8) "RBRACK",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "RSHIFT",
        (pANTLR3_UINT8) "RSHIFT_EQUALS",
        (pANTLR3_UINT8) "SLASH",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "TILDE",
        (pANTLR3_UINT8) "TIMES_EQUAL",
        (pANTLR3_UINT8) "TRIPLE_COLON",
        (pANTLR3_UINT8) "VALID_NAME",
        (pANTLR3_UINT8) "WHITESPACE"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 parser_ProgramNode ___
	program    (pCortolangParser ctx);
static 
 parser_StatementNode ___
	statement    (pCortolangParser ctx);
static 
 parser_StatementNode ___
	declarativeStatement    (pCortolangParser ctx);
static 
 parser_StatementNode ___
	simpleStatement    (pCortolangParser ctx);
static 
 void
	compositeStatement    (pCortolangParser ctx);
static 
 parser_StatementNode ___
	block    (pCortolangParser ctx);
static 
 parser_StatementNode ___
	declarationExt    (pCortolangParser ctx);
static 
 corto_ll ___
	declarationNameList    (pCortolangParser ctx);
static 
 parser_ObjectDeclarationNameNode ___
	declarationName    (pCortolangParser ctx);
static 
 parser_FullCommaExpressionNode ___
	initializer    (pCortolangParser ctx);
static 
 corto_bool ___
	scopeOp    (pCortolangParser ctx);
static 
 parser_ScopeNode ___
	scope_    (pCortolangParser ctx);
static 
 parser_StatementNode ___
	functionDeclaration    (pCortolangParser ctx);
static 
 corto_ll ___
	functionParameters    (pCortolangParser ctx);
static 
 parser_FunctionParameterNode ___
	functionParameter    (pCortolangParser ctx);
static 
 void
	ifStatement    (pCortolangParser ctx);
static 
 void
	elseStatement    (pCortolangParser ctx);
static 
 void
	whileStatement    (pCortolangParser ctx);
static 
 void
	breakStatement    (pCortolangParser ctx);
static 
 void
	continueStatement    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	expression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	assignmentExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	simpleCommaExpression    (pCortolangParser ctx);
static 
 parser_FullCommaExpressionNode ___
	fullCommaExpression    (pCortolangParser ctx);
static 
 parser_FullCommaExpressionElementNode ___
	commaExpressionElem    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	conditionalExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	logicOrExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	logicAndExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	equalityExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	comparisonExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	bitOrExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	bitXorExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	bitAndExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	shiftExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	addExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	multExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	unaryExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	postfixExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	atomExpression    (pCortolangParser ctx);
static 
 void
	anonymousObject    (pCortolangParser ctx);
static 
 void
	observerStatement    (pCortolangParser ctx);
static 
 void
	eventMask    (pCortolangParser ctx);
static 
 void
	eventFlag    (pCortolangParser ctx);
static 
 void
	eventBaseFlag    (pCortolangParser ctx);
static 
 void
	eventScopeFlag    (pCortolangParser ctx);
static 
 corto_operatorKind ___ ___
	assignmentOp    (pCortolangParser ctx);
static 
 corto_operatorKind ___
	eqOp    (pCortolangParser ctx);
static 
 corto_operatorKind ___
	comparisonOp    (pCortolangParser ctx);
static 
 corto_operatorKind ___
	shiftOp    (pCortolangParser ctx);
static 
 corto_operatorKind ___
	addOp    (pCortolangParser ctx);
static 
 corto_operatorKind ___
	multOp    (pCortolangParser ctx);
static 
 corto_operatorKind ___
	unaryOp    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	postfixOperation    (pCortolangParser ctx, parser_ExpressionNode ___ _node);
static 
 parser_ExpressionNode ___
	functionCall    (pCortolangParser ctx, parser_ExpressionNode ___ _node);
static 
 parser_ExpressionNode ___
	memberAccess    (pCortolangParser ctx, parser_ExpressionNode ___ _node);
static 
 parser_ExpressionNode ___
	elementAccess    (pCortolangParser ctx, parser_ExpressionNode ___ _node);
static 
 void
	constant    (pCortolangParser ctx);
static 
 CortolangParser_identifier_return
	identifier    (pCortolangParser ctx);
static 
 parser_BaseTypeExpressionNode ___
	typeLabel    (pCortolangParser ctx);
static 
 parser_LiteralNode ___
	literal    (pCortolangParser ctx);
static 
 parser_LiteralNode ___
	booleanLiteral    (pCortolangParser ctx);
static 
 parser_LiteralNode ___
	integerLiteral    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred1_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred2_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred3_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred4_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred5_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred6_Cortolang    (pCortolangParser ctx);
static void	CortolangParserFree(pCortolangParser ctx);
static void     CortolangParserReset (pCortolangParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Cortolang.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new CortolangParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCortolangParser
CortolangParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return CortolangParserNewSSD(instream, NULL);
}

/** \brief Create a new CortolangParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCortolangParser
CortolangParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pCortolangParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pCortolangParser) ANTLR3_CALLOC(1, sizeof(CortolangParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in CortolangParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our CortolangParser interface
     */
    ctx->program	= program;
    ctx->statement	= statement;
    ctx->declarativeStatement	= declarativeStatement;
    ctx->simpleStatement	= simpleStatement;
    ctx->compositeStatement	= compositeStatement;
    ctx->block	= block;
    ctx->declarationExt	= declarationExt;
    ctx->declarationNameList	= declarationNameList;
    ctx->declarationName	= declarationName;
    ctx->initializer	= initializer;
    ctx->scopeOp	= scopeOp;
    ctx->scope_	= scope_;
    ctx->functionDeclaration	= functionDeclaration;
    ctx->functionParameters	= functionParameters;
    ctx->functionParameter	= functionParameter;
    ctx->ifStatement	= ifStatement;
    ctx->elseStatement	= elseStatement;
    ctx->whileStatement	= whileStatement;
    ctx->breakStatement	= breakStatement;
    ctx->continueStatement	= continueStatement;
    ctx->expression	= expression;
    ctx->assignmentExpression	= assignmentExpression;
    ctx->simpleCommaExpression	= simpleCommaExpression;
    ctx->fullCommaExpression	= fullCommaExpression;
    ctx->commaExpressionElem	= commaExpressionElem;
    ctx->conditionalExpression	= conditionalExpression;
    ctx->logicOrExpression	= logicOrExpression;
    ctx->logicAndExpression	= logicAndExpression;
    ctx->equalityExpression	= equalityExpression;
    ctx->comparisonExpression	= comparisonExpression;
    ctx->bitOrExpression	= bitOrExpression;
    ctx->bitXorExpression	= bitXorExpression;
    ctx->bitAndExpression	= bitAndExpression;
    ctx->shiftExpression	= shiftExpression;
    ctx->addExpression	= addExpression;
    ctx->multExpression	= multExpression;
    ctx->unaryExpression	= unaryExpression;
    ctx->postfixExpression	= postfixExpression;
    ctx->atomExpression	= atomExpression;
    ctx->anonymousObject	= anonymousObject;
    ctx->observerStatement	= observerStatement;
    ctx->eventMask	= eventMask;
    ctx->eventFlag	= eventFlag;
    ctx->eventBaseFlag	= eventBaseFlag;
    ctx->eventScopeFlag	= eventScopeFlag;
    ctx->assignmentOp	= assignmentOp;
    ctx->eqOp	= eqOp;
    ctx->comparisonOp	= comparisonOp;
    ctx->shiftOp	= shiftOp;
    ctx->addOp	= addOp;
    ctx->multOp	= multOp;
    ctx->unaryOp	= unaryOp;
    ctx->postfixOperation	= postfixOperation;
    ctx->functionCall	= functionCall;
    ctx->memberAccess	= memberAccess;
    ctx->elementAccess	= elementAccess;
    ctx->constant	= constant;
    ctx->identifier	= identifier;
    ctx->typeLabel	= typeLabel;
    ctx->literal	= literal;
    ctx->booleanLiteral	= booleanLiteral;
    ctx->integerLiteral	= integerLiteral;
    ctx->synpred1_Cortolang	= synpred1_Cortolang;
    ctx->synpred2_Cortolang	= synpred2_Cortolang;
    ctx->synpred3_Cortolang	= synpred3_Cortolang;
    ctx->synpred4_Cortolang	= synpred4_Cortolang;
    ctx->synpred5_Cortolang	= synpred5_Cortolang;
    ctx->synpred6_Cortolang	= synpred6_Cortolang;
    ctx->free			= CortolangParserFree;
    ctx->reset			= CortolangParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */


    RECOGNIZER->displayRecognitionError = parser_pw_displayRecognitionError;
    ctx->parser_data = NULL;
    PARSER->super = ctx;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = CortolangParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
CortolangParserReset (pCortolangParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 CortolangParserFree(pCortolangParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return CortolangParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_program137  */
static	ANTLR3_BITWORD FOLLOW_statement_in_program137_bits[]	= { ANTLR3_UINT64_LIT(0x248320E868110082), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_program137	= { FOLLOW_statement_in_program137_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarativeStatement_in_statement195  */
static	ANTLR3_BITWORD FOLLOW_declarativeStatement_in_statement195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarativeStatement_in_statement195	= { FOLLOW_declarativeStatement_in_statement195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleStatement_in_statement213  */
static	ANTLR3_BITWORD FOLLOW_simpleStatement_in_statement213_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleStatement_in_statement213	= { FOLLOW_simpleStatement_in_statement213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_statement215  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_statement215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_statement215	= { FOLLOW_NEWLINE_in_statement215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compositeStatement_in_statement233  */
static	ANTLR3_BITWORD FOLLOW_compositeStatement_in_statement233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compositeStatement_in_statement233	= { FOLLOW_compositeStatement_in_statement233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_statement251  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_statement251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_statement251	= { FOLLOW_NEWLINE_in_statement251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_declarativeStatement292  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_declarativeStatement292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_declarativeStatement292	= { FOLLOW_functionDeclaration_in_declarativeStatement292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationExt_in_declarativeStatement320  */
static	ANTLR3_BITWORD FOLLOW_declarationExt_in_declarativeStatement320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationExt_in_declarativeStatement320	= { FOLLOW_declarationExt_in_declarativeStatement320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_simpleStatement359  */
static	ANTLR3_BITWORD FOLLOW_expression_in_simpleStatement359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_simpleStatement359	= { FOLLOW_expression_in_simpleStatement359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_breakStatement_in_simpleStatement377  */
static	ANTLR3_BITWORD FOLLOW_breakStatement_in_simpleStatement377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_breakStatement_in_simpleStatement377	= { FOLLOW_breakStatement_in_simpleStatement377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_continueStatement_in_simpleStatement389  */
static	ANTLR3_BITWORD FOLLOW_continueStatement_in_simpleStatement389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_continueStatement_in_simpleStatement389	= { FOLLOW_continueStatement_in_simpleStatement389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_compositeStatement411  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_compositeStatement411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_compositeStatement411	= { FOLLOW_ifStatement_in_compositeStatement411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_compositeStatement423  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_compositeStatement423_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_compositeStatement423	= { FOLLOW_whileStatement_in_compositeStatement423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_observerStatement_in_compositeStatement435  */
static	ANTLR3_BITWORD FOLLOW_observerStatement_in_compositeStatement435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_observerStatement_in_compositeStatement435	= { FOLLOW_observerStatement_in_compositeStatement435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_block466  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_block466_bits[]	= { ANTLR3_UINT64_LIT(0x248320E86C110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_block466	= { FOLLOW_COLON_in_block466_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_block498  */
static	ANTLR3_BITWORD FOLLOW_statement_in_block498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_block498	= { FOLLOW_statement_in_block498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDENT_in_block542  */
static	ANTLR3_BITWORD FOLLOW_INDENT_in_block542_bits[]	= { ANTLR3_UINT64_LIT(0x248320E868110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_INDENT_in_block542	= { FOLLOW_INDENT_in_block542_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_block568  */
static	ANTLR3_BITWORD FOLLOW_statement_in_block568_bits[]	= { ANTLR3_UINT64_LIT(0x248320E868110880), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_block568	= { FOLLOW_statement_in_block568_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEDENT_in_block603  */
static	ANTLR3_BITWORD FOLLOW_DEDENT_in_block603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DEDENT_in_block603	= { FOLLOW_DEDENT_in_block603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLabel_in_declarationExt681  */
static	ANTLR3_BITWORD FOLLOW_typeLabel_in_declarationExt681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLabel_in_declarationExt681	= { FOLLOW_typeLabel_in_declarationExt681_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationNameList_in_declarationExt696  */
static	ANTLR3_BITWORD FOLLOW_declarationNameList_in_declarationExt696_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000008100), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationNameList_in_declarationExt696	= { FOLLOW_declarationNameList_in_declarationExt696_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initializer_in_declarationExt704  */
static	ANTLR3_BITWORD FOLLOW_initializer_in_declarationExt704_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000008000), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_initializer_in_declarationExt704	= { FOLLOW_initializer_in_declarationExt704_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_declarationExt721  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_declarationExt721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_declarationExt721	= { FOLLOW_NEWLINE_in_declarationExt721_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_scope__in_declarationExt743  */
static	ANTLR3_BITWORD FOLLOW_scope__in_declarationExt743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_scope__in_declarationExt743	= { FOLLOW_scope__in_declarationExt743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationName_in_declarationNameList808  */
static	ANTLR3_BITWORD FOLLOW_declarationName_in_declarationNameList808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationName_in_declarationNameList808	= { FOLLOW_declarationName_in_declarationNameList808_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_declarationNameList840  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_declarationNameList840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_declarationNameList840	= { FOLLOW_COMMA_in_declarationNameList840_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationName_in_declarationNameList852  */
static	ANTLR3_BITWORD FOLLOW_declarationName_in_declarationNameList852_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationName_in_declarationNameList852	= { FOLLOW_declarationName_in_declarationNameList852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_declarationName900  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_declarationName900_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_declarationName900	= { FOLLOW_VALID_NAME_in_declarationName900_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACE_in_declarationName916  */
static	ANTLR3_BITWORD FOLLOW_LBRACE_in_declarationName916_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C10) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACE_in_declarationName916	= { FOLLOW_LBRACE_in_declarationName916_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_declarationName928  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_declarationName928_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_declarationName928	= { FOLLOW_fullCommaExpression_in_declarationName928_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACE_in_declarationName938  */
static	ANTLR3_BITWORD FOLLOW_RBRACE_in_declarationName938_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACE_in_declarationName938	= { FOLLOW_RBRACE_in_declarationName938_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_initializer982  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_initializer982_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_initializer982	= { FOLLOW_COLON_in_initializer982_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_initializer998  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_initializer998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_initializer998	= { FOLLOW_fullCommaExpression_in_initializer998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRIPLE_COLON_in_scopeOp1045  */
static	ANTLR3_BITWORD FOLLOW_TRIPLE_COLON_in_scopeOp1045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRIPLE_COLON_in_scopeOp1045	= { FOLLOW_TRIPLE_COLON_in_scopeOp1045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_COLON_in_scopeOp1063  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_COLON_in_scopeOp1063_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_COLON_in_scopeOp1063	= { FOLLOW_DOUBLE_COLON_in_scopeOp1063_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_scopeOp_in_scope_1094  */
static	ANTLR3_BITWORD FOLLOW_scopeOp_in_scope_1094_bits[]	= { ANTLR3_UINT64_LIT(0x248320E86C110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_scopeOp_in_scope_1094	= { FOLLOW_scopeOp_in_scope_1094_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_scope_1126  */
static	ANTLR3_BITWORD FOLLOW_statement_in_scope_1126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_scope_1126	= { FOLLOW_statement_in_scope_1126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDENT_in_scope_1170  */
static	ANTLR3_BITWORD FOLLOW_INDENT_in_scope_1170_bits[]	= { ANTLR3_UINT64_LIT(0x248320E868110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_INDENT_in_scope_1170	= { FOLLOW_INDENT_in_scope_1170_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_scope_1196  */
static	ANTLR3_BITWORD FOLLOW_statement_in_scope_1196_bits[]	= { ANTLR3_UINT64_LIT(0x248320E868110880), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_scope_1196	= { FOLLOW_statement_in_scope_1196_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEDENT_in_scope_1231  */
static	ANTLR3_BITWORD FOLLOW_DEDENT_in_scope_1231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DEDENT_in_scope_1231	= { FOLLOW_DEDENT_in_scope_1231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLabel_in_functionDeclaration1281  */
static	ANTLR3_BITWORD FOLLOW_typeLabel_in_functionDeclaration1281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLabel_in_functionDeclaration1281	= { FOLLOW_typeLabel_in_functionDeclaration1281_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_functionDeclaration1289  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_functionDeclaration1289_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_functionDeclaration1289	= { FOLLOW_VALID_NAME_in_functionDeclaration1289_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_functionDeclaration1295  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_functionDeclaration1295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000), ANTLR3_UINT64_LIT(0x0000000000004040) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_functionDeclaration1295	= { FOLLOW_LPAREN_in_functionDeclaration1295_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionParameters_in_functionDeclaration1303  */
static	ANTLR3_BITWORD FOLLOW_functionParameters_in_functionDeclaration1303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_functionParameters_in_functionDeclaration1303	= { FOLLOW_functionParameters_in_functionDeclaration1303_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_functionDeclaration1309  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_functionDeclaration1309_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000020100) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_functionDeclaration1309	= { FOLLOW_RPAREN_in_functionDeclaration1309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_functionDeclaration1325  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_functionDeclaration1325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_functionDeclaration1325	= { FOLLOW_NEWLINE_in_functionDeclaration1325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_functionDeclaration1345  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_functionDeclaration1345_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_functionDeclaration1345	= { FOLLOW_EQUAL_in_functionDeclaration1345_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_functionDeclaration1349  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_functionDeclaration1349_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_functionDeclaration1349	= { FOLLOW_conditionalExpression_in_functionDeclaration1349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_functionDeclaration1351  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_functionDeclaration1351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_functionDeclaration1351	= { FOLLOW_NEWLINE_in_functionDeclaration1351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_functionDeclaration1373  */
static	ANTLR3_BITWORD FOLLOW_block_in_functionDeclaration1373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_functionDeclaration1373	= { FOLLOW_block_in_functionDeclaration1373_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionParameter_in_functionParameters1442  */
static	ANTLR3_BITWORD FOLLOW_functionParameter_in_functionParameters1442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_functionParameter_in_functionParameters1442	= { FOLLOW_functionParameter_in_functionParameters1442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_functionParameters1490  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_functionParameters1490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_functionParameters1490	= { FOLLOW_COMMA_in_functionParameters1490_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionParameter_in_functionParameters1506  */
static	ANTLR3_BITWORD FOLLOW_functionParameter_in_functionParameters1506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_functionParameter_in_functionParameters1506	= { FOLLOW_functionParameter_in_functionParameters1506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLabel_in_functionParameter1575  */
static	ANTLR3_BITWORD FOLLOW_typeLabel_in_functionParameter1575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLabel_in_functionParameter1575	= { FOLLOW_typeLabel_in_functionParameter1575_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_functionParameter1581  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_functionParameter1581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_functionParameter1581	= { FOLLOW_VALID_NAME_in_functionParameter1581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_IF_in_ifStatement1614  */
static	ANTLR3_BITWORD FOLLOW_KW_IF_in_ifStatement1614_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_IF_in_ifStatement1614	= { FOLLOW_KW_IF_in_ifStatement1614_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_ifStatement1616  */
static	ANTLR3_BITWORD FOLLOW_expression_in_ifStatement1616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_ifStatement1616	= { FOLLOW_expression_in_ifStatement1616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_ifStatement1632  */
static	ANTLR3_BITWORD FOLLOW_block_in_ifStatement1632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_ifStatement1632	= { FOLLOW_block_in_ifStatement1632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elseStatement_in_ifStatement1672  */
static	ANTLR3_BITWORD FOLLOW_elseStatement_in_ifStatement1672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elseStatement_in_ifStatement1672	= { FOLLOW_elseStatement_in_ifStatement1672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ELSE_in_elseStatement1702  */
static	ANTLR3_BITWORD FOLLOW_KW_ELSE_in_elseStatement1702_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ELSE_in_elseStatement1702	= { FOLLOW_KW_ELSE_in_elseStatement1702_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_elseStatement1704  */
static	ANTLR3_BITWORD FOLLOW_block_in_elseStatement1704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_elseStatement1704	= { FOLLOW_block_in_elseStatement1704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_WHILE_in_whileStatement1725  */
static	ANTLR3_BITWORD FOLLOW_KW_WHILE_in_whileStatement1725_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_WHILE_in_whileStatement1725	= { FOLLOW_KW_WHILE_in_whileStatement1725_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_whileStatement1727  */
static	ANTLR3_BITWORD FOLLOW_expression_in_whileStatement1727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_whileStatement1727	= { FOLLOW_expression_in_whileStatement1727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_whileStatement1729  */
static	ANTLR3_BITWORD FOLLOW_block_in_whileStatement1729_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_whileStatement1729	= { FOLLOW_block_in_whileStatement1729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_BREAK_in_breakStatement1750  */
static	ANTLR3_BITWORD FOLLOW_KW_BREAK_in_breakStatement1750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_BREAK_in_breakStatement1750	= { FOLLOW_KW_BREAK_in_breakStatement1750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CONTINUE_in_continueStatement1771  */
static	ANTLR3_BITWORD FOLLOW_KW_CONTINUE_in_continueStatement1771_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CONTINUE_in_continueStatement1771	= { FOLLOW_KW_CONTINUE_in_continueStatement1771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignmentExpression_in_expression1807  */
static	ANTLR3_BITWORD FOLLOW_assignmentExpression_in_expression1807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignmentExpression_in_expression1807	= { FOLLOW_assignmentExpression_in_expression1807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleCommaExpression_in_assignmentExpression1856  */
static	ANTLR3_BITWORD FOLLOW_simpleCommaExpression_in_assignmentExpression1856_bits[]	= { ANTLR3_UINT64_LIT(0x1800000001022222), ANTLR3_UINT64_LIT(0x0000000000001005) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleCommaExpression_in_assignmentExpression1856	= { FOLLOW_simpleCommaExpression_in_assignmentExpression1856_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignmentOp_in_assignmentExpression1904  */
static	ANTLR3_BITWORD FOLLOW_assignmentOp_in_assignmentExpression1904_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_assignmentOp_in_assignmentExpression1904	= { FOLLOW_assignmentOp_in_assignmentExpression1904_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleCommaExpression_in_assignmentExpression1926  */
static	ANTLR3_BITWORD FOLLOW_simpleCommaExpression_in_assignmentExpression1926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleCommaExpression_in_assignmentExpression1926	= { FOLLOW_simpleCommaExpression_in_assignmentExpression1926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_simpleCommaExpression1986  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_simpleCommaExpression1986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_simpleCommaExpression1986	= { FOLLOW_conditionalExpression_in_simpleCommaExpression1986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_simpleCommaExpression2018  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_simpleCommaExpression2018_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_simpleCommaExpression2018	= { FOLLOW_COMMA_in_simpleCommaExpression2018_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_simpleCommaExpression2030  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_simpleCommaExpression2030_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_simpleCommaExpression2030	= { FOLLOW_conditionalExpression_in_simpleCommaExpression2030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_simpleCommaExpression2053  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_simpleCommaExpression2053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_simpleCommaExpression2053	= { FOLLOW_COMMA_in_simpleCommaExpression2053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_commaExpressionElem_in_fullCommaExpression2113  */
static	ANTLR3_BITWORD FOLLOW_commaExpressionElem_in_fullCommaExpression2113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_commaExpressionElem_in_fullCommaExpression2113	= { FOLLOW_commaExpressionElem_in_fullCommaExpression2113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_fullCommaExpression2161  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_fullCommaExpression2161_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_fullCommaExpression2161	= { FOLLOW_COMMA_in_fullCommaExpression2161_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_commaExpressionElem_in_fullCommaExpression2177  */
static	ANTLR3_BITWORD FOLLOW_commaExpressionElem_in_fullCommaExpression2177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_commaExpressionElem_in_fullCommaExpression2177	= { FOLLOW_commaExpressionElem_in_fullCommaExpression2177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_fullCommaExpression2212  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_fullCommaExpression2212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_fullCommaExpression2212	= { FOLLOW_COMMA_in_fullCommaExpression2212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_commaExpressionElem2269  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_commaExpressionElem2269_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_commaExpressionElem2269	= { FOLLOW_conditionalExpression_in_commaExpressionElem2269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_commaExpressionElem2291  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_commaExpressionElem2291_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_commaExpressionElem2291	= { FOLLOW_EQUAL_in_commaExpressionElem2291_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_commaExpressionElem2303  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_commaExpressionElem2303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_commaExpressionElem2303	= { FOLLOW_conditionalExpression_in_commaExpressionElem2303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicOrExpression_in_conditionalExpression2359  */
static	ANTLR3_BITWORD FOLLOW_logicOrExpression_in_conditionalExpression2359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_logicOrExpression_in_conditionalExpression2359	= { FOLLOW_logicOrExpression_in_conditionalExpression2359_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QMARK_in_conditionalExpression2391  */
static	ANTLR3_BITWORD FOLLOW_QMARK_in_conditionalExpression2391_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_QMARK_in_conditionalExpression2391	= { FOLLOW_QMARK_in_conditionalExpression2391_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicOrExpression_in_conditionalExpression2403  */
static	ANTLR3_BITWORD FOLLOW_logicOrExpression_in_conditionalExpression2403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_logicOrExpression_in_conditionalExpression2403	= { FOLLOW_logicOrExpression_in_conditionalExpression2403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_conditionalExpression2413  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_conditionalExpression2413_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_conditionalExpression2413	= { FOLLOW_COLON_in_conditionalExpression2413_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicOrExpression_in_conditionalExpression2425  */
static	ANTLR3_BITWORD FOLLOW_logicOrExpression_in_conditionalExpression2425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logicOrExpression_in_conditionalExpression2425	= { FOLLOW_logicOrExpression_in_conditionalExpression2425_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicAndExpression_in_logicOrExpression2485  */
static	ANTLR3_BITWORD FOLLOW_logicAndExpression_in_logicOrExpression2485_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logicAndExpression_in_logicOrExpression2485	= { FOLLOW_logicAndExpression_in_logicOrExpression2485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_OR_in_logicOrExpression2517  */
static	ANTLR3_BITWORD FOLLOW_KW_OR_in_logicOrExpression2517_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_OR_in_logicOrExpression2517	= { FOLLOW_KW_OR_in_logicOrExpression2517_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicAndExpression_in_logicOrExpression2529  */
static	ANTLR3_BITWORD FOLLOW_logicAndExpression_in_logicOrExpression2529_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logicAndExpression_in_logicOrExpression2529	= { FOLLOW_logicAndExpression_in_logicOrExpression2529_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalityExpression_in_logicAndExpression2589  */
static	ANTLR3_BITWORD FOLLOW_equalityExpression_in_logicAndExpression2589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_equalityExpression_in_logicAndExpression2589	= { FOLLOW_equalityExpression_in_logicAndExpression2589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_AND_in_logicAndExpression2621  */
static	ANTLR3_BITWORD FOLLOW_KW_AND_in_logicAndExpression2621_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_AND_in_logicAndExpression2621	= { FOLLOW_KW_AND_in_logicAndExpression2621_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalityExpression_in_logicAndExpression2633  */
static	ANTLR3_BITWORD FOLLOW_equalityExpression_in_logicAndExpression2633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_equalityExpression_in_logicAndExpression2633	= { FOLLOW_equalityExpression_in_logicAndExpression2633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparisonExpression_in_equalityExpression2693  */
static	ANTLR3_BITWORD FOLLOW_comparisonExpression_in_equalityExpression2693_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_comparisonExpression_in_equalityExpression2693	= { FOLLOW_comparisonExpression_in_equalityExpression2693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eqOp_in_equalityExpression2727  */
static	ANTLR3_BITWORD FOLLOW_eqOp_in_equalityExpression2727_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_eqOp_in_equalityExpression2727	= { FOLLOW_eqOp_in_equalityExpression2727_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparisonExpression_in_equalityExpression2739  */
static	ANTLR3_BITWORD FOLLOW_comparisonExpression_in_equalityExpression2739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comparisonExpression_in_equalityExpression2739	= { FOLLOW_comparisonExpression_in_equalityExpression2739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitOrExpression_in_comparisonExpression2799  */
static	ANTLR3_BITWORD FOLLOW_bitOrExpression_in_comparisonExpression2799_bits[]	= { ANTLR3_UINT64_LIT(0x0030000000600002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitOrExpression_in_comparisonExpression2799	= { FOLLOW_bitOrExpression_in_comparisonExpression2799_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparisonOp_in_comparisonExpression2833  */
static	ANTLR3_BITWORD FOLLOW_comparisonOp_in_comparisonExpression2833_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_comparisonOp_in_comparisonExpression2833	= { FOLLOW_comparisonOp_in_comparisonExpression2833_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitOrExpression_in_comparisonExpression2845  */
static	ANTLR3_BITWORD FOLLOW_bitOrExpression_in_comparisonExpression2845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitOrExpression_in_comparisonExpression2845	= { FOLLOW_bitOrExpression_in_comparisonExpression2845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitXorExpression_in_bitOrExpression2905  */
static	ANTLR3_BITWORD FOLLOW_bitXorExpression_in_bitOrExpression2905_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitXorExpression_in_bitOrExpression2905	= { FOLLOW_bitXorExpression_in_bitOrExpression2905_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PIPE_in_bitOrExpression2937  */
static	ANTLR3_BITWORD FOLLOW_PIPE_in_bitOrExpression2937_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_PIPE_in_bitOrExpression2937	= { FOLLOW_PIPE_in_bitOrExpression2937_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitXorExpression_in_bitOrExpression2949  */
static	ANTLR3_BITWORD FOLLOW_bitXorExpression_in_bitOrExpression2949_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitXorExpression_in_bitOrExpression2949	= { FOLLOW_bitXorExpression_in_bitOrExpression2949_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitAndExpression_in_bitXorExpression3009  */
static	ANTLR3_BITWORD FOLLOW_bitAndExpression_in_bitXorExpression3009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitAndExpression_in_bitXorExpression3009	= { FOLLOW_bitAndExpression_in_bitXorExpression3009_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HAT_in_bitXorExpression3041  */
static	ANTLR3_BITWORD FOLLOW_HAT_in_bitXorExpression3041_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_HAT_in_bitXorExpression3041	= { FOLLOW_HAT_in_bitXorExpression3041_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitAndExpression_in_bitXorExpression3053  */
static	ANTLR3_BITWORD FOLLOW_bitAndExpression_in_bitXorExpression3053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitAndExpression_in_bitXorExpression3053	= { FOLLOW_bitAndExpression_in_bitXorExpression3053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_shiftExpression_in_bitAndExpression3113  */
static	ANTLR3_BITWORD FOLLOW_shiftExpression_in_bitAndExpression3113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_shiftExpression_in_bitAndExpression3113	= { FOLLOW_shiftExpression_in_bitAndExpression3113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_bitAndExpression3145  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_bitAndExpression3145_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_bitAndExpression3145	= { FOLLOW_AMPERSAND_in_bitAndExpression3145_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_shiftExpression_in_bitAndExpression3157  */
static	ANTLR3_BITWORD FOLLOW_shiftExpression_in_bitAndExpression3157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_shiftExpression_in_bitAndExpression3157	= { FOLLOW_shiftExpression_in_bitAndExpression3157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addExpression_in_shiftExpression3217  */
static	ANTLR3_BITWORD FOLLOW_addExpression_in_shiftExpression3217_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000002), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_addExpression_in_shiftExpression3217	= { FOLLOW_addExpression_in_shiftExpression3217_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_shiftOp_in_shiftExpression3251  */
static	ANTLR3_BITWORD FOLLOW_shiftOp_in_shiftExpression3251_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_shiftOp_in_shiftExpression3251	= { FOLLOW_shiftOp_in_shiftExpression3251_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addExpression_in_shiftExpression3263  */
static	ANTLR3_BITWORD FOLLOW_addExpression_in_shiftExpression3263_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000002), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_addExpression_in_shiftExpression3263	= { FOLLOW_addExpression_in_shiftExpression3263_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multExpression_in_addExpression3323  */
static	ANTLR3_BITWORD FOLLOW_multExpression_in_addExpression3323_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multExpression_in_addExpression3323	= { FOLLOW_multExpression_in_addExpression3323_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addOp_in_addExpression3373  */
static	ANTLR3_BITWORD FOLLOW_addOp_in_addExpression3373_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_addOp_in_addExpression3373	= { FOLLOW_addOp_in_addExpression3373_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multExpression_in_addExpression3385  */
static	ANTLR3_BITWORD FOLLOW_multExpression_in_addExpression3385_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multExpression_in_addExpression3385	= { FOLLOW_multExpression_in_addExpression3385_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpression_in_multExpression3445  */
static	ANTLR3_BITWORD FOLLOW_unaryExpression_in_multExpression3445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpression_in_multExpression3445	= { FOLLOW_unaryExpression_in_multExpression3445_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multOp_in_multExpression3479  */
static	ANTLR3_BITWORD FOLLOW_multOp_in_multExpression3479_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_multOp_in_multExpression3479	= { FOLLOW_multOp_in_multExpression3479_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpression_in_multExpression3491  */
static	ANTLR3_BITWORD FOLLOW_unaryExpression_in_multExpression3491_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpression_in_multExpression3491	= { FOLLOW_unaryExpression_in_multExpression3491_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryOp_in_unaryExpression3541  */
static	ANTLR3_BITWORD FOLLOW_unaryOp_in_unaryExpression3541_bits[]	= { ANTLR3_UINT64_LIT(0x0082200808100080), ANTLR3_UINT64_LIT(0x0000000000004400) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryOp_in_unaryExpression3541	= { FOLLOW_unaryOp_in_unaryExpression3541_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postfixExpression_in_unaryExpression3546  */
static	ANTLR3_BITWORD FOLLOW_postfixExpression_in_unaryExpression3546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_postfixExpression_in_unaryExpression3546	= { FOLLOW_postfixExpression_in_unaryExpression3546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomExpression_in_postfixExpression3595  */
static	ANTLR3_BITWORD FOLLOW_atomExpression_in_postfixExpression3595_bits[]	= { ANTLR3_UINT64_LIT(0x0084000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomExpression_in_postfixExpression3595	= { FOLLOW_atomExpression_in_postfixExpression3595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postfixOperation_in_postfixExpression3627  */
static	ANTLR3_BITWORD FOLLOW_postfixOperation_in_postfixExpression3627_bits[]	= { ANTLR3_UINT64_LIT(0x0084000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_postfixOperation_in_postfixExpression3627	= { FOLLOW_postfixOperation_in_postfixExpression3627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_atomExpression3677  */
static	ANTLR3_BITWORD FOLLOW_literal_in_atomExpression3677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_atomExpression3677	= { FOLLOW_literal_in_atomExpression3677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_atomExpression3695  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_atomExpression3695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_atomExpression3695	= { FOLLOW_identifier_in_atomExpression3695_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_atomExpression3713  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_atomExpression3713_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_atomExpression3713	= { FOLLOW_LPAREN_in_atomExpression3713_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_atomExpression3717  */
static	ANTLR3_BITWORD FOLLOW_expression_in_atomExpression3717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_atomExpression3717	= { FOLLOW_expression_in_atomExpression3717_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_atomExpression3719  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_atomExpression3719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_atomExpression3719	= { FOLLOW_RPAREN_in_atomExpression3719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anonymousObject_in_atomExpression3737  */
static	ANTLR3_BITWORD FOLLOW_anonymousObject_in_atomExpression3737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anonymousObject_in_atomExpression3737	= { FOLLOW_anonymousObject_in_atomExpression3737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACE_in_anonymousObject3758  */
static	ANTLR3_BITWORD FOLLOW_LBRACE_in_anonymousObject3758_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C10) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACE_in_anonymousObject3758	= { FOLLOW_LBRACE_in_anonymousObject3758_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_anonymousObject3760  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_anonymousObject3760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_anonymousObject3760	= { FOLLOW_fullCommaExpression_in_anonymousObject3760_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACE_in_anonymousObject3762  */
static	ANTLR3_BITWORD FOLLOW_RBRACE_in_anonymousObject3762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACE_in_anonymousObject3762	= { FOLLOW_RBRACE_in_anonymousObject3762_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ON_in_observerStatement3787  */
static	ANTLR3_BITWORD FOLLOW_KW_ON_in_observerStatement3787_bits[]	= { ANTLR3_UINT64_LIT(0x00005E0380000000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ON_in_observerStatement3787	= { FOLLOW_KW_ON_in_observerStatement3787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventMask_in_observerStatement3789  */
static	ANTLR3_BITWORD FOLLOW_eventMask_in_observerStatement3789_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_eventMask_in_observerStatement3789	= { FOLLOW_eventMask_in_observerStatement3789_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_observerStatement3791  */
static	ANTLR3_BITWORD FOLLOW_expression_in_observerStatement3791_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_observerStatement3791	= { FOLLOW_expression_in_observerStatement3791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_observerStatement3795  */
static	ANTLR3_BITWORD FOLLOW_block_in_observerStatement3795_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_observerStatement3795	= { FOLLOW_block_in_observerStatement3795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_observerStatement3799  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_observerStatement3799_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_observerStatement3799	= { FOLLOW_NEWLINE_in_observerStatement3799_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventFlag_in_eventMask3822  */
static	ANTLR3_BITWORD FOLLOW_eventFlag_in_eventMask3822_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_eventFlag_in_eventMask3822	= { FOLLOW_eventFlag_in_eventMask3822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PIPE_in_eventMask3826  */
static	ANTLR3_BITWORD FOLLOW_PIPE_in_eventMask3826_bits[]	= { ANTLR3_UINT64_LIT(0x00005E0380000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PIPE_in_eventMask3826	= { FOLLOW_PIPE_in_eventMask3826_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventFlag_in_eventMask3828  */
static	ANTLR3_BITWORD FOLLOW_eventFlag_in_eventMask3828_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_eventFlag_in_eventMask3828	= { FOLLOW_eventFlag_in_eventMask3828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventBaseFlag_in_eventFlag3844  */
static	ANTLR3_BITWORD FOLLOW_eventBaseFlag_in_eventFlag3844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_eventBaseFlag_in_eventFlag3844	= { FOLLOW_eventBaseFlag_in_eventFlag3844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventScopeFlag_in_eventFlag3848  */
static	ANTLR3_BITWORD FOLLOW_eventScopeFlag_in_eventFlag3848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_eventScopeFlag_in_eventFlag3848	= { FOLLOW_eventScopeFlag_in_eventFlag3848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_assignmentOp3925  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_assignmentOp3925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_assignmentOp3925	= { FOLLOW_EQUAL_in_assignmentOp3925_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_EQUAL_in_assignmentOp3943  */
static	ANTLR3_BITWORD FOLLOW_PLUS_EQUAL_in_assignmentOp3943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_EQUAL_in_assignmentOp3943	= { FOLLOW_PLUS_EQUAL_in_assignmentOp3943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_EQUAL_in_assignmentOp3961  */
static	ANTLR3_BITWORD FOLLOW_MINUS_EQUAL_in_assignmentOp3961_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_EQUAL_in_assignmentOp3961	= { FOLLOW_MINUS_EQUAL_in_assignmentOp3961_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TIMES_EQUAL_in_assignmentOp3979  */
static	ANTLR3_BITWORD FOLLOW_TIMES_EQUAL_in_assignmentOp3979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TIMES_EQUAL_in_assignmentOp3979	= { FOLLOW_TIMES_EQUAL_in_assignmentOp3979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIV_EQUAL_in_assignmentOp3997  */
static	ANTLR3_BITWORD FOLLOW_DIV_EQUAL_in_assignmentOp3997_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIV_EQUAL_in_assignmentOp3997	= { FOLLOW_DIV_EQUAL_in_assignmentOp3997_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MOD_EQUAL_in_assignmentOp4015  */
static	ANTLR3_BITWORD FOLLOW_MOD_EQUAL_in_assignmentOp4015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MOD_EQUAL_in_assignmentOp4015	= { FOLLOW_MOD_EQUAL_in_assignmentOp4015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HAT_EQUAL_in_assignmentOp4033  */
static	ANTLR3_BITWORD FOLLOW_HAT_EQUAL_in_assignmentOp4033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HAT_EQUAL_in_assignmentOp4033	= { FOLLOW_HAT_EQUAL_in_assignmentOp4033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PIPE_EQUAL_in_assignmentOp4051  */
static	ANTLR3_BITWORD FOLLOW_PIPE_EQUAL_in_assignmentOp4051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PIPE_EQUAL_in_assignmentOp4051	= { FOLLOW_PIPE_EQUAL_in_assignmentOp4051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMP_EQUAL_in_assignmentOp4069  */
static	ANTLR3_BITWORD FOLLOW_AMP_EQUAL_in_assignmentOp4069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AMP_EQUAL_in_assignmentOp4069	= { FOLLOW_AMP_EQUAL_in_assignmentOp4069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_EQUAL_in_assignmentOp4087  */
static	ANTLR3_BITWORD FOLLOW_COLON_EQUAL_in_assignmentOp4087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_EQUAL_in_assignmentOp4087	= { FOLLOW_COLON_EQUAL_in_assignmentOp4087_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_eqOp4124  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_eqOp4124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_eqOp4124	= { FOLLOW_EQUALS_in_eqOp4124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_EQUALS_in_eqOp4142  */
static	ANTLR3_BITWORD FOLLOW_NOT_EQUALS_in_eqOp4142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_EQUALS_in_eqOp4142	= { FOLLOW_NOT_EQUALS_in_eqOp4142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_in_comparisonOp4179  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_in_comparisonOp4179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GREATER_THAN_in_comparisonOp4179	= { FOLLOW_GREATER_THAN_in_comparisonOp4179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_in_comparisonOp4197  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_in_comparisonOp4197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_in_comparisonOp4197	= { FOLLOW_LESS_THAN_in_comparisonOp4197_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_EQUAL_in_comparisonOp4215  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_EQUAL_in_comparisonOp4215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GREATER_THAN_EQUAL_in_comparisonOp4215	= { FOLLOW_GREATER_THAN_EQUAL_in_comparisonOp4215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_EQUAL_in_comparisonOp4233  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_EQUAL_in_comparisonOp4233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_EQUAL_in_comparisonOp4233	= { FOLLOW_LESS_THAN_EQUAL_in_comparisonOp4233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LSHIFT_in_shiftOp4270  */
static	ANTLR3_BITWORD FOLLOW_LSHIFT_in_shiftOp4270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LSHIFT_in_shiftOp4270	= { FOLLOW_LSHIFT_in_shiftOp4270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSHIFT_in_shiftOp4288  */
static	ANTLR3_BITWORD FOLLOW_RSHIFT_in_shiftOp4288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RSHIFT_in_shiftOp4288	= { FOLLOW_RSHIFT_in_shiftOp4288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_addOp4325  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_addOp4325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_addOp4325	= { FOLLOW_PLUS_in_addOp4325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_addOp4343  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_addOp4343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_addOp4343	= { FOLLOW_MINUS_in_addOp4343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASTERISK_in_multOp4380  */
static	ANTLR3_BITWORD FOLLOW_ASTERISK_in_multOp4380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ASTERISK_in_multOp4380	= { FOLLOW_ASTERISK_in_multOp4380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_multOp4398  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_multOp4398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_multOp4398	= { FOLLOW_SLASH_in_multOp4398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TILDE_in_unaryOp4435  */
static	ANTLR3_BITWORD FOLLOW_TILDE_in_unaryOp4435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TILDE_in_unaryOp4435	= { FOLLOW_TILDE_in_unaryOp4435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_unaryOp4453  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_unaryOp4453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_unaryOp4453	= { FOLLOW_MINUS_in_unaryOp4453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EMARK_in_unaryOp4496  */
static	ANTLR3_BITWORD FOLLOW_EMARK_in_unaryOp4496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EMARK_in_unaryOp4496	= { FOLLOW_EMARK_in_unaryOp4496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_NOT_in_unaryOp4514  */
static	ANTLR3_BITWORD FOLLOW_KW_NOT_in_unaryOp4514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_NOT_in_unaryOp4514	= { FOLLOW_KW_NOT_in_unaryOp4514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionCall_in_postfixOperation4552  */
static	ANTLR3_BITWORD FOLLOW_functionCall_in_postfixOperation4552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionCall_in_postfixOperation4552	= { FOLLOW_functionCall_in_postfixOperation4552_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_memberAccess_in_postfixOperation4572  */
static	ANTLR3_BITWORD FOLLOW_memberAccess_in_postfixOperation4572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_memberAccess_in_postfixOperation4572	= { FOLLOW_memberAccess_in_postfixOperation4572_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elementAccess_in_postfixOperation4592  */
static	ANTLR3_BITWORD FOLLOW_elementAccess_in_postfixOperation4592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elementAccess_in_postfixOperation4592	= { FOLLOW_elementAccess_in_postfixOperation4592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_functionCall4633  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_functionCall4633_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C40) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_functionCall4633	= { FOLLOW_LPAREN_in_functionCall4633_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_functionCall4641  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_functionCall4641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_functionCall4641	= { FOLLOW_fullCommaExpression_in_functionCall4641_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_functionCall4647  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_functionCall4647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_functionCall4647	= { FOLLOW_RPAREN_in_functionCall4647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_memberAccess4686  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_memberAccess4686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_memberAccess4686	= { FOLLOW_DOT_in_memberAccess4686_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_memberAccess4688  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_memberAccess4688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_memberAccess4688	= { FOLLOW_VALID_NAME_in_memberAccess4688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_in_elementAccess4728  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_in_elementAccess4728_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C20) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_in_elementAccess4728	= { FOLLOW_LBRACK_in_elementAccess4728_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_elementAccess4730  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_elementAccess4730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_elementAccess4730	= { FOLLOW_fullCommaExpression_in_elementAccess4730_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_in_elementAccess4732  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_in_elementAccess4732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_in_elementAccess4732	= { FOLLOW_RBRACK_in_elementAccess4732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_constant4765  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_constant4765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_constant4765	= { FOLLOW_VALID_NAME_in_constant4765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GID_in_constant4777  */
static	ANTLR3_BITWORD FOLLOW_GID_in_constant4777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GID_in_constant4777	= { FOLLOW_GID_in_constant4777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_constant4789  */
static	ANTLR3_BITWORD FOLLOW_literal_in_constant4789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_constant4789	= { FOLLOW_literal_in_constant4789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_typeLabel4863  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_typeLabel4863_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_typeLabel4863	= { FOLLOW_identifier_in_typeLabel4863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACE_in_typeLabel4895  */
static	ANTLR3_BITWORD FOLLOW_LBRACE_in_typeLabel4895_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C10) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACE_in_typeLabel4895	= { FOLLOW_LBRACE_in_typeLabel4895_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_typeLabel4905  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_typeLabel4905_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_typeLabel4905	= { FOLLOW_fullCommaExpression_in_typeLabel4905_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACE_in_typeLabel4915  */
static	ANTLR3_BITWORD FOLLOW_RBRACE_in_typeLabel4915_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACE_in_typeLabel4915	= { FOLLOW_RBRACE_in_typeLabel4915_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_booleanLiteral_in_literal4963  */
static	ANTLR3_BITWORD FOLLOW_booleanLiteral_in_literal4963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_booleanLiteral_in_literal4963	= { FOLLOW_booleanLiteral_in_literal4963_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHARACTER_in_literal4981  */
static	ANTLR3_BITWORD FOLLOW_CHARACTER_in_literal4981_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHARACTER_in_literal4981	= { FOLLOW_CHARACTER_in_literal4981_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integerLiteral_in_literal4993  */
static	ANTLR3_BITWORD FOLLOW_integerLiteral_in_literal4993_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integerLiteral_in_literal4993	= { FOLLOW_integerLiteral_in_literal4993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_literal5011  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_literal5011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_literal5011	= { FOLLOW_STRING_in_literal5011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_TRUE_in_booleanLiteral5052  */
static	ANTLR3_BITWORD FOLLOW_KW_TRUE_in_booleanLiteral5052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_TRUE_in_booleanLiteral5052	= { FOLLOW_KW_TRUE_in_booleanLiteral5052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_FALSE_in_booleanLiteral5082  */
static	ANTLR3_BITWORD FOLLOW_KW_FALSE_in_booleanLiteral5082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_FALSE_in_booleanLiteral5082	= { FOLLOW_KW_FALSE_in_booleanLiteral5082_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_integerLiteral5135  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_integerLiteral5135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_integerLiteral5135	= { FOLLOW_INTEGER_in_integerLiteral5135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarativeStatement_in_synpred1_Cortolang186  */
static	ANTLR3_BITWORD FOLLOW_declarativeStatement_in_synpred1_Cortolang186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarativeStatement_in_synpred1_Cortolang186	= { FOLLOW_declarativeStatement_in_synpred1_Cortolang186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_synpred2_Cortolang283  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_synpred2_Cortolang283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_synpred2_Cortolang283	= { FOLLOW_functionDeclaration_in_synpred2_Cortolang283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationExt_in_synpred3_Cortolang311  */
static	ANTLR3_BITWORD FOLLOW_declarationExt_in_synpred3_Cortolang311_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationExt_in_synpred3_Cortolang311	= { FOLLOW_declarationExt_in_synpred3_Cortolang311_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLabel_in_synpred4_Cortolang664  */
static	ANTLR3_BITWORD FOLLOW_typeLabel_in_synpred4_Cortolang664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLabel_in_synpred4_Cortolang664	= { FOLLOW_typeLabel_in_synpred4_Cortolang664_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationNameList_in_synpred4_Cortolang666  */
static	ANTLR3_BITWORD FOLLOW_declarationNameList_in_synpred4_Cortolang666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationNameList_in_synpred4_Cortolang666	= { FOLLOW_declarationNameList_in_synpred4_Cortolang666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ELSE_in_synpred5_Cortolang1656  */
static	ANTLR3_BITWORD FOLLOW_KW_ELSE_in_synpred5_Cortolang1656_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ELSE_in_synpred5_Cortolang1656	= { FOLLOW_KW_ELSE_in_synpred5_Cortolang1656_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addOp_in_synpred6_Cortolang3356  */
static	ANTLR3_BITWORD FOLLOW_addOp_in_synpred6_Cortolang3356_bits[]	= { ANTLR3_UINT64_LIT(0x0482204808110080), ANTLR3_UINT64_LIT(0x0000000000004C00) };
static  ANTLR3_BITSET_LIST FOLLOW_addOp_in_synpred6_Cortolang3356	= { FOLLOW_addOp_in_synpred6_Cortolang3356_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multExpression_in_synpred6_Cortolang3358  */
static	ANTLR3_BITWORD FOLLOW_multExpression_in_synpred6_Cortolang3358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multExpression_in_synpred6_Cortolang3358	= { FOLLOW_multExpression_in_synpred6_Cortolang3358_bits, 1	};



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    69:1: statement returns [ parser_StatementNode ___ node ] : ( ( declarativeStatement )=> declarativeStatement | simpleStatement NEWLINE | compositeStatement | NEWLINE );
 */
static const ANTLR3_INT32 dfa2_eot[17] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa2_eof[17] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa2_min[17] =
    {
	7, 4, 4, -1, -1, -1, -1, -1, 5, -1, 0, -1, -1, -1, 4, -1, 0
    };
static const ANTLR3_INT32 dfa2_max[17] =
    {
	78, 78, 78, -1, -1, -1, -1, -1, 78, -1, 0, -1, -1, -1, 77, -1, 0
    };
static const ANTLR3_INT32 dfa2_accept[17] =
    {
	-1, -1, -1, 2, 3, 4, 1, 1, -1, 1, -1, 1, 1, 1, -1, 1, -1
    };
static const ANTLR3_INT32 dfa2_special[17] =
    {
	-1, 2, 0, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, 1, -1, 3
    };

/** Used when there is no transition table entry for a particular state */
#define dfa2_T_empty	    NULL

static const ANTLR3_INT32 dfa2_T0[] =
    {
	3, 3, 3, -1, -1, 3, 3, -1, -1, 3, 3, -1, -1, 3, 3, -1, -1, 3, 3, 3, 3, 
	-1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, 
	-1, -1, -1, -1, -1, 13, 3, -1, 3, 3, -1, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, -1, -1, -1, 3, -1, 3, -1, -1, 3, -1, 7
    };

static const ANTLR3_INT32 dfa2_T1[] =
    {
	3, 3, 3, -1, 9, 3, 8, -1, -1, 3, 3, 12, -1, 3, 3, -1, -1, 3, 3, 3, 3, -1, 
	-1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, 15, 3, -1, 3, 3, -1, 3, 3, -1, 3, 3, 3, 16, 3, 3, 3, 3, 
	3, 3, -1, -1, -1, 3, -1, 3, -1, -1, 3, 11
    };

static const ANTLR3_INT32 dfa2_T2[] =
    {
	3, 3, 3, -1, 9, 3, 8, -1, -1, 3, 3, 12, -1, 3, 3, -1, -1, 3, 3, 3, 3, -1, 
	-1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, 6, 3, -1, 3, 3, -1, 3, 3, -1, 3, 3, 3, 10, 3, 3, 3, 3, 
	3, 3, -1, -1, -1, 3, -1, 3, -1, -1, 3, 11, 7
    };

static const ANTLR3_INT32 dfa2_T3[] =
    {
	3, -1, 3, -1, 3, -1, -1, -1, 3, -1, -1, 3, 3, -1, -1, 3, -1, -1, -1, 3, 
	-1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, 3, -1, -1, -1, -1, -1, 
	-1, 3, -1, -1, -1, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, -1, -1, 
	3, -1, 3, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, -1, 14
    };

static const ANTLR3_INT32 dfa2_T4[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, 2, -1, -1, -1, -1, -1, 
	-1, 3, -1, 3, 3, -1, -1, -1, -1, 3, -1, 4, 3, 4, -1, -1, -1, -1, -1, 3, 
	-1, -1, 4, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, -1, -1, 5, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, -1, -1, 1
    };

static const ANTLR3_INT32 dfa2_T5[] =
    {
	-1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa2_transitions[] =
{
    dfa2_T4, dfa2_T2, dfa2_T0, NULL, NULL, NULL, NULL, NULL, dfa2_T3, NULL, 
    dfa2_T5, NULL, NULL, NULL, dfa2_T1, NULL, dfa2_T5
};

static ANTLR3_INT32 dfa2_sst(pCortolangParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA2_2;

    	    ANTLR3_MARKER index2_2;


    		LA2_2 = LA(1);

    	     
    	        index2_2 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (synpred1_Cortolang(ctx)) && (LA2_2 == LBRACE) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (synpred1_Cortolang(ctx)) && (LA2_2 == VALID_NAME) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (((LA2_2 >= AMPERSAND) && (LA2_2 <= ASTERISK)) || ((LA2_2 >= COLON_EQUAL) && (LA2_2 <= COMMA)) || ((LA2_2 >= DIV_EQUAL) && (LA2_2 <= DOT)) || ((LA2_2 >= EQUAL) && (LA2_2 <= EQUALS)) || ((LA2_2 >= GREATER_THAN) && (LA2_2 <= HAT_EQUAL)) || LA2_2 == KW_AND || LA2_2 == KW_OR || LA2_2 == LBRACK || ((LA2_2 >= LESS_THAN) && (LA2_2 <= LESS_THAN_EQUAL)) || ((LA2_2 >= LPAREN) && (LA2_2 <= LSHIFT)) || ((LA2_2 >= MINUS) && (LA2_2 <= QMARK)) || LA2_2 == RSHIFT || LA2_2 == SLASH || LA2_2 == TIMES_EQUAL) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index2_2);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA2_14;

    	    ANTLR3_MARKER index2_14;


    		LA2_14 = LA(1);

    	     
    	        index2_14 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (synpred1_Cortolang(ctx)) && (LA2_14 == LBRACE) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (synpred1_Cortolang(ctx)) && (LA2_14 == COLON) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA2_14 == NEWLINE) )
    	    {
    	        s = 16;
    	    }

    	    else if ( (synpred1_Cortolang(ctx)) && (LA2_14 == TRIPLE_COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (synpred1_Cortolang(ctx)) && (LA2_14 == DOUBLE_COLON) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA2_14 == COMMA) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA2_14 >= AMPERSAND) && (LA2_14 <= ASTERISK)) || LA2_14 == COLON_EQUAL || ((LA2_14 >= DIV_EQUAL) && (LA2_14 <= DOT)) || ((LA2_14 >= EQUAL) && (LA2_14 <= EQUALS)) || ((LA2_14 >= GREATER_THAN) && (LA2_14 <= HAT_EQUAL)) || LA2_14 == KW_AND || LA2_14 == KW_OR || LA2_14 == LBRACK || ((LA2_14 >= LESS_THAN) && (LA2_14 <= LESS_THAN_EQUAL)) || ((LA2_14 >= LPAREN) && (LA2_14 <= LSHIFT)) || ((LA2_14 >= MINUS) && (LA2_14 <= MOD_EQUAL)) || ((LA2_14 >= NOT_EQUALS) && (LA2_14 <= QMARK)) || LA2_14 == RSHIFT || LA2_14 == SLASH || LA2_14 == TIMES_EQUAL) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index2_14);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA2_1;

    	    ANTLR3_MARKER index2_1;


    		LA2_1 = LA(1);

    	     
    	        index2_1 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (synpred1_Cortolang(ctx)) && (LA2_1 == LBRACE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (synpred1_Cortolang(ctx)) && (LA2_1 == VALID_NAME) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA2_1 == COMMA) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (synpred1_Cortolang(ctx)) && (LA2_1 == COLON) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA2_1 == NEWLINE) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (synpred1_Cortolang(ctx)) && (LA2_1 == TRIPLE_COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (synpred1_Cortolang(ctx)) && (LA2_1 == DOUBLE_COLON) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA2_1 >= AMPERSAND) && (LA2_1 <= ASTERISK)) || LA2_1 == COLON_EQUAL || ((LA2_1 >= DIV_EQUAL) && (LA2_1 <= DOT)) || ((LA2_1 >= EQUAL) && (LA2_1 <= EQUALS)) || ((LA2_1 >= GREATER_THAN) && (LA2_1 <= HAT_EQUAL)) || LA2_1 == KW_AND || LA2_1 == KW_OR || LA2_1 == LBRACK || ((LA2_1 >= LESS_THAN) && (LA2_1 <= LESS_THAN_EQUAL)) || ((LA2_1 >= LPAREN) && (LA2_1 <= LSHIFT)) || ((LA2_1 >= MINUS) && (LA2_1 <= MOD_EQUAL)) || ((LA2_1 >= NOT_EQUALS) && (LA2_1 <= QMARK)) || LA2_1 == RSHIFT || LA2_1 == SLASH || LA2_1 == TIMES_EQUAL) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index2_1);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA2_16;

    	    ANTLR3_MARKER index2_16;


    		LA2_16 = LA(1);

    	     
    	        index2_16 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (synpred1_Cortolang(ctx)) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index2_16);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 4:

    	{
    	    ANTLR3_UINT32 LA2_10;

    	    ANTLR3_MARKER index2_10;


    		LA2_10 = LA(1);

    	     
    	        index2_10 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (synpred1_Cortolang(ctx)) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index2_10);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"69:1: statement returns [ parser_StatementNode ___ node ] : ( ( declarativeStatement )=> declarativeStatement | simpleStatement NEWLINE | compositeStatement | NEWLINE );";
    EXCEPTION->decisionNum  = 2;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 2
 */
static
ANTLR3_CYCLIC_DFA cdfa2
    =	{
	    2,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"69:1: statement returns [ parser_StatementNode ___ node ] : ( ( declarativeStatement )=> declarativeStatement | simpleStatement NEWLINE | compositeStatement | NEWLINE );",
	    (CDFA_SPECIAL_FUNC) dfa2_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa2_eot,	    /* EOT table			    */
	    dfa2_eof,	    /* EOF table			    */
	    dfa2_min,	    /* Minimum tokens for each state    */
	    dfa2_max,	    /* Maximum tokens for each state    */
	    dfa2_accept,	/* Accept table			    */
	    dfa2_special,	/* Special transition states	    */
	    dfa2_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 2
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * Cortolang.g:51:1: program returns [ parser_ProgramNode ___ node ] : ( statement )+ ;
 */
static parser_ProgramNode ___
program(pCortolangParser ctx)
{
    parser_ProgramNode ___ node;


    parser_StatementNode ___ statement1;
    #undef	RETURN_TYPE_statement1
    #define	RETURN_TYPE_statement1 parser_StatementNode ___

    /* Initialize rule variables
     */


        node = parser_ProgramNodeCreate(0, 0, corto_llNew());

    {
        // Cortolang.g:57:5: ( ( statement )+ )
        // Cortolang.g:58:5: ( statement )+
        {
            // Cortolang.g:58:5: ( statement )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) )
            	{
            	case CHARACTER:
            	case EMARK:
            	case GID:
            	case INTEGER:
            	case KW_BREAK:
            	case KW_CONTINUE:
            	case KW_FALSE:
            	case KW_IF:
            	case KW_NOT:
            	case KW_ON:
            	case KW_TRUE:
            	case KW_WHILE:
            	case LBRACE:
            	case LPAREN:
            	case MINUS:
            	case NEWLINE:
            	case STRING:
            	case TILDE:
            	case VALID_NAME:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1)
            	{
            	    case 1:
            	        // Cortolang.g:59:9: statement
            	        {
            	            FOLLOWPUSH(FOLLOW_statement_in_program137);
            	            statement1=statement(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return node;
            	            }


            	            if ( BACKTRACKING==0 )
            	            {

            	                            if (statement1
            	                ) {
            	                                corto_llAppend(node->statements, statement1
            	                );
            	                            }
            	                        
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return node;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleprogramEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end program */

/**
 * $ANTLR start statement
 * Cortolang.g:69:1: statement returns [ parser_StatementNode ___ node ] : ( ( declarativeStatement )=> declarativeStatement | simpleStatement NEWLINE | compositeStatement | NEWLINE );
 */
static parser_StatementNode ___
statement(pCortolangParser ctx)
{
    parser_StatementNode ___ node;


    parser_StatementNode ___ declarativeStatement2;
    #undef	RETURN_TYPE_declarativeStatement2
    #define	RETURN_TYPE_declarativeStatement2 parser_StatementNode ___

    parser_StatementNode ___ simpleStatement3;
    #undef	RETURN_TYPE_simpleStatement3
    #define	RETURN_TYPE_simpleStatement3 parser_StatementNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        {
            //  Cortolang.g:75:5: ( ( declarativeStatement )=> declarativeStatement | simpleStatement NEWLINE | compositeStatement | NEWLINE )

            ANTLR3_UINT32 alt2;

            alt2=4;

            alt2 = cdfa2.predict(ctx, RECOGNIZER, ISTREAM, &cdfa2);
            if  (HASEXCEPTION())
            {
                goto rulestatementEx;
            }
            if (HASFAILED())
            {
                return node;
            }

            switch (alt2)
            {
        	case 1:
        	    // Cortolang.g:76:5: ( declarativeStatement )=> declarativeStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_declarativeStatement_in_statement195);
        	        declarativeStatement2=declarativeStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = declarativeStatement2
        	            ;
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:82:5: simpleStatement NEWLINE
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleStatement_in_statement213);
        	        simpleStatement3=simpleStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_statement215);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = simpleStatement3
        	            ;
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:87:5: compositeStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_compositeStatement_in_statement233);
        	        compositeStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:90:5: NEWLINE
        	    {
        	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_statement251);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end statement */

/**
 * $ANTLR start declarativeStatement
 * Cortolang.g:94:1: declarativeStatement returns [ parser_StatementNode ___ node ] : ( ( functionDeclaration )=> functionDeclaration | ( declarationExt )=> declarationExt );
 */
static parser_StatementNode ___
declarativeStatement(pCortolangParser ctx)
{
    parser_StatementNode ___ node;


    parser_StatementNode ___ functionDeclaration4;
    #undef	RETURN_TYPE_functionDeclaration4
    #define	RETURN_TYPE_functionDeclaration4 parser_StatementNode ___

    parser_StatementNode ___ declarationExt5;
    #undef	RETURN_TYPE_declarationExt5
    #define	RETURN_TYPE_declarationExt5 parser_StatementNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        {
            //  Cortolang.g:100:5: ( ( functionDeclaration )=> functionDeclaration | ( declarationExt )=> declarationExt )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case VALID_NAME:
            	{
            		{
            		    int LA3_1 = LA(2);
            		    if ( (synpred2_Cortolang(ctx)))
            		    {
            		        alt3=1;
            		    }
            		    else if ( (synpred3_Cortolang(ctx)))
            		    {
            		        alt3=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return node;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 3;
            		        EXCEPTION->state        = 1;


            		        goto ruledeclarativeStatementEx;

            		    }
            		}
            	}
                break;
            case GID:
            	{
            		{
            		    int LA3_2 = LA(2);
            		    if ( (synpred2_Cortolang(ctx)))
            		    {
            		        alt3=1;
            		    }
            		    else if ( (synpred3_Cortolang(ctx)))
            		    {
            		        alt3=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return node;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 3;
            		        EXCEPTION->state        = 2;


            		        goto ruledeclarativeStatementEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return node;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruledeclarativeStatementEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // Cortolang.g:101:5: ( functionDeclaration )=> functionDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_functionDeclaration_in_declarativeStatement292);
        	        functionDeclaration4=functionDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarativeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = functionDeclaration4
        	            ;
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:107:5: ( declarationExt )=> declarationExt
        	    {
        	        FOLLOWPUSH(FOLLOW_declarationExt_in_declarativeStatement320);
        	        declarationExt5=declarationExt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarativeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = declarationExt5
        	            ;
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclarativeStatementEx; /* Prevent compiler warnings */
    ruledeclarativeStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end declarativeStatement */

/**
 * $ANTLR start simpleStatement
 * Cortolang.g:115:1: simpleStatement returns [ parser_StatementNode ___ node ] : (e= expression | breakStatement | continueStatement );
 */
static parser_StatementNode ___
simpleStatement(pCortolangParser ctx)
{
    parser_StatementNode ___ node;


    parser_ExpressionNode ___ e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        {
            //  Cortolang.g:121:5: (e= expression | breakStatement | continueStatement )

            ANTLR3_UINT32 alt4;

            alt4=3;

            switch ( LA(1) )
            {
            case CHARACTER:
            case EMARK:
            case GID:
            case INTEGER:
            case KW_FALSE:
            case KW_NOT:
            case KW_TRUE:
            case LBRACE:
            case LPAREN:
            case MINUS:
            case STRING:
            case TILDE:
            case VALID_NAME:
            	{
            		alt4=1;
            	}
                break;
            case KW_BREAK:
            	{
            		alt4=2;
            	}
                break;
            case KW_CONTINUE:
            	{
            		alt4=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return node;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto rulesimpleStatementEx;

            }

            switch (alt4)
            {
        	case 1:
        	    // Cortolang.g:122:5: e= expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_simpleStatement359);
        	        e=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    // TODO line and column
        	                    parser_ExpressionStatementNode _node = parser_ExpressionStatementNodeCreate(
        	                        0, 0, e

        	                    );
        	                    node = parser_StatementNode(_node);
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:131:5: breakStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_breakStatement_in_simpleStatement377);
        	        breakStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:133:5: continueStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_continueStatement_in_simpleStatement389);
        	        continueStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleStatementEx; /* Prevent compiler warnings */
    rulesimpleStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end simpleStatement */

/**
 * $ANTLR start compositeStatement
 * Cortolang.g:137:1: compositeStatement : ( ifStatement | whileStatement | observerStatement );
 */
static void
compositeStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:138:5: ( ifStatement | whileStatement | observerStatement )

            ANTLR3_UINT32 alt5;

            alt5=3;

            switch ( LA(1) )
            {
            case KW_IF:
            	{
            		alt5=1;
            	}
                break;
            case KW_WHILE:
            	{
            		alt5=2;
            	}
                break;
            case KW_ON:
            	{
            		alt5=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rulecompositeStatementEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // Cortolang.g:139:5: ifStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_ifStatement_in_compositeStatement411);
        	        ifStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompositeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:141:5: whileStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_whileStatement_in_compositeStatement423);
        	        whileStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompositeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:143:5: observerStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_observerStatement_in_compositeStatement435);
        	        observerStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompositeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecompositeStatementEx; /* Prevent compiler warnings */
    rulecompositeStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end compositeStatement */

/**
 * $ANTLR start block
 * Cortolang.g:147:1: block returns [ parser_StatementNode ___ node ] : COLON ( (s1= statement ) | INDENT (s2= statement )+ DEDENT ) ;
 */
static parser_StatementNode ___
block(pCortolangParser ctx)
{
    parser_StatementNode ___ node;


    parser_StatementNode ___ s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 parser_StatementNode ___

    parser_StatementNode ___ s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 parser_StatementNode ___

    /* Initialize rule variables
     */


        parser_BlockNode _node = parser_BlockNodeCreate(0, 0, corto_llNew());
        node = NULL;

    {
        // Cortolang.g:154:5: ( COLON ( (s1= statement ) | INDENT (s2= statement )+ DEDENT ) )
        // Cortolang.g:155:5: COLON ( (s1= statement ) | INDENT (s2= statement )+ DEDENT )
        {
             MATCHT(COLON, &FOLLOW_COLON_in_block466);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            // Cortolang.g:156:5: ( (s1= statement ) | INDENT (s2= statement )+ DEDENT )
            {
                int alt7=2;
                switch ( LA(1) )
                {
                case CHARACTER:
                case EMARK:
                case GID:
                case INTEGER:
                case KW_BREAK:
                case KW_CONTINUE:
                case KW_FALSE:
                case KW_IF:
                case KW_NOT:
                case KW_ON:
                case KW_TRUE:
                case KW_WHILE:
                case LBRACE:
                case LPAREN:
                case MINUS:
                case NEWLINE:
                case STRING:
                case TILDE:
                case VALID_NAME:
                	{
                		alt7=1;
                	}
                    break;
                case INDENT:
                	{
                		alt7=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return node;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 7;
                    EXCEPTION->state        = 0;


                    goto ruleblockEx;

                }

                switch (alt7)
                {
            	case 1:
            	    // Cortolang.g:157:9: (s1= statement )
            	    {
            	        // Cortolang.g:157:9: (s1= statement )
            	        // Cortolang.g:158:13: s1= statement
            	        {
            	            FOLLOWPUSH(FOLLOW_statement_in_block498);
            	            s1=statement(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleblockEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return node;
            	            }


            	            if ( BACKTRACKING==0 )
            	            {

            	                                corto_llAppend(_node->statements, s1
            	                );
            	                            
            	            }


            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:164:9: INDENT (s2= statement )+ DEDENT
            	    {
            	         MATCHT(INDENT, &FOLLOW_INDENT_in_block542);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        // Cortolang.g:165:9: (s2= statement )+
            	        {
            	            int cnt6=0;

            	            for (;;)
            	            {
            	                int alt6=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case CHARACTER:
            	        	case EMARK:
            	        	case GID:
            	        	case INTEGER:
            	        	case KW_BREAK:
            	        	case KW_CONTINUE:
            	        	case KW_FALSE:
            	        	case KW_IF:
            	        	case KW_NOT:
            	        	case KW_ON:
            	        	case KW_TRUE:
            	        	case KW_WHILE:
            	        	case LBRACE:
            	        	case LPAREN:
            	        	case MINUS:
            	        	case NEWLINE:
            	        	case STRING:
            	        	case TILDE:
            	        	case VALID_NAME:
            	        		{
            	        			alt6=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt6)
            	        	{
            	        	    case 1:
            	        	        // Cortolang.g:166:13: s2= statement
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_statement_in_block568);
            	        	            s2=statement(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleblockEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return node;
            	        	            }


            	        	            if ( BACKTRACKING==0 )
            	        	            {

            	        	                                corto_llAppend(_node->statements, s2
            	        	                );
            	        	                            
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt6 >= 1 )
            	        		{
            	        		    goto loop6;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    return node;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruleblockEx;
            	        	}
            	        	cnt6++;
            	            }
            	            loop6: ;	/* Jump to here if this rule does not match */
            	        }

            	         MATCHT(DEDENT, &FOLLOW_DEDENT_in_block603);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                        node = parser_StatementNode(_node);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end block */

/**
 * $ANTLR start declarationExt
 * Cortolang.g:197:1: declarationExt returns [ parser_StatementNode ___ node ] : ( ( typeLabel declarationNameList )=>tl= typeLabel )? dnl= declarationNameList (ini= initializer )? ( NEWLINE |s= scope_ ) ;
 */
static parser_StatementNode ___
declarationExt(pCortolangParser ctx)
{
    parser_StatementNode ___ node;


    parser_BaseTypeExpressionNode ___ tl;
    #undef	RETURN_TYPE_tl
    #define	RETURN_TYPE_tl parser_BaseTypeExpressionNode ___

    corto_ll ___ dnl;
    #undef	RETURN_TYPE_dnl
    #define	RETURN_TYPE_dnl corto_ll ___

    parser_FullCommaExpressionNode ___ ini;
    #undef	RETURN_TYPE_ini
    #define	RETURN_TYPE_ini parser_FullCommaExpressionNode ___

    parser_ScopeNode ___ s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s parser_ScopeNode ___

    /* Initialize rule variables
     */


        parser_ObjectDeclarationNode _node = parser_ObjectDeclarationNodeDeclare();
        tl = NULL;
        node = parser_StatementNode(_node);
        ini = NULL;

    {
        // Cortolang.g:205:5: ( ( ( typeLabel declarationNameList )=>tl= typeLabel )? dnl= declarationNameList (ini= initializer )? ( NEWLINE |s= scope_ ) )
        // Cortolang.g:207:5: ( ( typeLabel declarationNameList )=>tl= typeLabel )? dnl= declarationNameList (ini= initializer )? ( NEWLINE |s= scope_ )
        {
            // Cortolang.g:207:5: ( ( typeLabel declarationNameList )=>tl= typeLabel )?
            {
                int alt8=2;
                {
                    int LA8_0 = LA(1);
                    if ( (LA8_0 == VALID_NAME))
                    {
                        {
                            int LA8_1 = LA(2);
                            if ( (synpred4_Cortolang(ctx)))
                            {
                                alt8=1;
                            }
                        }
                    }
                    else if ( (synpred4_Cortolang(ctx)) && (LA8_0 == GID))
                    {
                        alt8=1;
                    }
                }
                switch (alt8)
                {
            	case 1:
            	    // Cortolang.g:208:9: ( typeLabel declarationNameList )=>tl= typeLabel
            	    {
            	        FOLLOWPUSH(FOLLOW_typeLabel_in_declarationExt681);
            	        tl=typeLabel(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationExtEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_declarationNameList_in_declarationExt696);
            dnl=declarationNameList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclarationExtEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            // Cortolang.g:212:8: (ini= initializer )?
            {
                int alt9=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt9=1;
                    	}
                        break;
                }

                switch (alt9)
                {
            	case 1:
            	    // Cortolang.g:212:8: ini= initializer
            	    {
            	        FOLLOWPUSH(FOLLOW_initializer_in_declarationExt704);
            	        ini=initializer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationExtEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            // Cortolang.g:213:5: ( NEWLINE |s= scope_ )
            {
                int alt10=2;
                switch ( LA(1) )
                {
                case NEWLINE:
                	{
                		alt10=1;
                	}
                    break;
                case DOUBLE_COLON:
                case TRIPLE_COLON:
                	{
                		alt10=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return node;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 10;
                    EXCEPTION->state        = 0;


                    goto ruledeclarationExtEx;

                }

                switch (alt10)
                {
            	case 1:
            	    // Cortolang.g:214:9: NEWLINE
            	    {
            	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_declarationExt721);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationExtEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:216:9: s= scope_
            	    {
            	        FOLLOWPUSH(FOLLOW_scope__in_declarationExt743);
            	        s=scope_(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationExtEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        _node->scope_ = s
            	            ;
            	                    
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                        _node->typeLabel = tl
                ;
                        _node->declarations = dnl
                ;
                        _node->initializer = ini
                 ? ini
                 : NULL;
                        corto_define(_node);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationExtEx; /* Prevent compiler warnings */
    ruledeclarationExtEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end declarationExt */

/**
 * $ANTLR start declarationNameList
 * Cortolang.g:230:1: declarationNameList returns [ corto_ll ___ nodes ] : (e1= declarationName ) ( COMMA e2= declarationName )* ;
 */
static corto_ll ___
declarationNameList(pCortolangParser ctx)
{
    corto_ll ___ nodes;


    parser_ObjectDeclarationNameNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ObjectDeclarationNameNode ___

    parser_ObjectDeclarationNameNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ObjectDeclarationNameNode ___

    /* Initialize rule variables
     */


        nodes = corto_llNew();

    {
        // Cortolang.g:236:5: ( (e1= declarationName ) ( COMMA e2= declarationName )* )
        // Cortolang.g:237:5: (e1= declarationName ) ( COMMA e2= declarationName )*
        {
            // Cortolang.g:237:5: (e1= declarationName )
            // Cortolang.g:238:9: e1= declarationName
            {
                FOLLOWPUSH(FOLLOW_declarationName_in_declarationNameList808);
                e1=declarationName(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruledeclarationNameListEx;
                }
                if (HASFAILED())
                {
                    return nodes;
                }


                if ( BACKTRACKING==0 )
                {

                                corto_llAppend(nodes, e1
                    );
                            
                }


            }


            // Cortolang.g:243:5: ( COMMA e2= declarationName )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11)
                {
            	case 1:
            	    // Cortolang.g:244:9: COMMA e2= declarationName
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_declarationNameList840);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationNameListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return nodes;
            	        }


            	        FOLLOWPUSH(FOLLOW_declarationName_in_declarationNameList852);
            	        e2=declarationName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationNameListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return nodes;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        corto_llAppend(nodes, e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationNameListEx; /* Prevent compiler warnings */
    ruledeclarationNameListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return nodes;
}
/* $ANTLR end declarationNameList */

/**
 * $ANTLR start declarationName
 * Cortolang.g:253:1: declarationName returns [ parser_ObjectDeclarationNameNode ___ node ] : VALID_NAME ( LBRACE fce= fullCommaExpression RBRACE )? ;
 */
static parser_ObjectDeclarationNameNode ___
declarationName(pCortolangParser ctx)
{
    parser_ObjectDeclarationNameNode ___ node;


    pANTLR3_COMMON_TOKEN    VALID_NAME6;
    parser_FullCommaExpressionNode ___ fce;
    #undef	RETURN_TYPE_fce
    #define	RETURN_TYPE_fce parser_FullCommaExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;
        fce = NULL;

    VALID_NAME6       = NULL;

    {
        // Cortolang.g:260:5: ( VALID_NAME ( LBRACE fce= fullCommaExpression RBRACE )? )
        // Cortolang.g:261:5: VALID_NAME ( LBRACE fce= fullCommaExpression RBRACE )?
        {
            VALID_NAME6 = (pANTLR3_COMMON_TOKEN) MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_declarationName900);
            if  (HASEXCEPTION())
            {
                goto ruledeclarationNameEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            // Cortolang.g:262:5: ( LBRACE fce= fullCommaExpression RBRACE )?
            {
                int alt12=2;
                switch ( LA(1) )
                {
                    case LBRACE:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // Cortolang.g:263:9: LBRACE fce= fullCommaExpression RBRACE
            	    {
            	         MATCHT(LBRACE, &FOLLOW_LBRACE_in_declarationName916);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationNameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_fullCommaExpression_in_declarationName928);
            	        fce=fullCommaExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationNameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	         MATCHT(RBRACE, &FOLLOW_RBRACE_in_declarationName938);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationNameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                        node = parser_ObjectDeclarationNameNodeCreate(
                            0, 0, CHARS((VALID_NAME6->getText(VALID_NAME6))), 
                fce

                        );
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationNameEx; /* Prevent compiler warnings */
    ruledeclarationNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end declarationName */

/**
 * $ANTLR start initializer
 * Cortolang.g:275:1: initializer returns [ parser_FullCommaExpressionNode ___ node ] : COLON ( fullCommaExpression ) ;
 */
static parser_FullCommaExpressionNode ___
initializer(pCortolangParser ctx)
{
    parser_FullCommaExpressionNode ___ node;


    parser_FullCommaExpressionNode ___ fullCommaExpression7;
    #undef	RETURN_TYPE_fullCommaExpression7
    #define	RETURN_TYPE_fullCommaExpression7 parser_FullCommaExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:281:5: ( COLON ( fullCommaExpression ) )
        // Cortolang.g:282:5: COLON ( fullCommaExpression )
        {
             MATCHT(COLON, &FOLLOW_COLON_in_initializer982);
            if  (HASEXCEPTION())
            {
                goto ruleinitializerEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            // Cortolang.g:283:5: ( fullCommaExpression )
            // Cortolang.g:284:9: fullCommaExpression
            {
                FOLLOWPUSH(FOLLOW_fullCommaExpression_in_initializer998);
                fullCommaExpression7=fullCommaExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleinitializerEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = fullCommaExpression7
                    ;
                            
                }


            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinitializerEx; /* Prevent compiler warnings */
    ruleinitializerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end initializer */

/**
 * $ANTLR start scopeOp
 * Cortolang.g:292:1: scopeOp returns [ corto_bool ___ isPostScope ] : ( TRIPLE_COLON | DOUBLE_COLON );
 */
static corto_bool ___
scopeOp(pCortolangParser ctx)
{
    corto_bool ___ isPostScope;


    /* Initialize rule variables
     */


        isPostScope = TRUE;

    {
        {
            //  Cortolang.g:297:5: ( TRIPLE_COLON | DOUBLE_COLON )

            ANTLR3_UINT32 alt13;

            alt13=2;

            switch ( LA(1) )
            {
            case TRIPLE_COLON:
            	{
            		alt13=1;
            	}
                break;
            case DOUBLE_COLON:
            	{
            		alt13=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return isPostScope;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto rulescopeOpEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // Cortolang.g:298:5: TRIPLE_COLON
        	    {
        	         MATCHT(TRIPLE_COLON, &FOLLOW_TRIPLE_COLON_in_scopeOp1045);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulescopeOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return isPostScope;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    isPostScope = FALSE;
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:303:5: DOUBLE_COLON
        	    {
        	         MATCHT(DOUBLE_COLON, &FOLLOW_DOUBLE_COLON_in_scopeOp1063);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulescopeOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return isPostScope;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulescopeOpEx; /* Prevent compiler warnings */
    rulescopeOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return isPostScope;
}
/* $ANTLR end scopeOp */

/**
 * $ANTLR start scope_
 * Cortolang.g:307:1: scope_ returns [ parser_ScopeNode ___ node ] : scopeOp ( (s1= statement ) | INDENT (s2= statement )+ DEDENT ) ;
 */
static parser_ScopeNode ___
scope_(pCortolangParser ctx)
{
    parser_ScopeNode ___ node;


    parser_StatementNode ___ s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 parser_StatementNode ___

    parser_StatementNode ___ s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 parser_StatementNode ___

    corto_bool ___ scopeOp8;
    #undef	RETURN_TYPE_scopeOp8
    #define	RETURN_TYPE_scopeOp8 corto_bool ___

    /* Initialize rule variables
     */


        node = parser_ScopeNodeDeclare();

    {
        // Cortolang.g:313:5: ( scopeOp ( (s1= statement ) | INDENT (s2= statement )+ DEDENT ) )
        // Cortolang.g:314:5: scopeOp ( (s1= statement ) | INDENT (s2= statement )+ DEDENT )
        {
            FOLLOWPUSH(FOLLOW_scopeOp_in_scope_1094);
            scopeOp8=scopeOp(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulescope_Ex;
            }
            if (HASFAILED())
            {
                return node;
            }


            // Cortolang.g:315:5: ( (s1= statement ) | INDENT (s2= statement )+ DEDENT )
            {
                int alt15=2;
                switch ( LA(1) )
                {
                case CHARACTER:
                case EMARK:
                case GID:
                case INTEGER:
                case KW_BREAK:
                case KW_CONTINUE:
                case KW_FALSE:
                case KW_IF:
                case KW_NOT:
                case KW_ON:
                case KW_TRUE:
                case KW_WHILE:
                case LBRACE:
                case LPAREN:
                case MINUS:
                case NEWLINE:
                case STRING:
                case TILDE:
                case VALID_NAME:
                	{
                		alt15=1;
                	}
                    break;
                case INDENT:
                	{
                		alt15=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return node;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 15;
                    EXCEPTION->state        = 0;


                    goto rulescope_Ex;

                }

                switch (alt15)
                {
            	case 1:
            	    // Cortolang.g:316:9: (s1= statement )
            	    {
            	        // Cortolang.g:316:9: (s1= statement )
            	        // Cortolang.g:317:13: s1= statement
            	        {
            	            FOLLOWPUSH(FOLLOW_statement_in_scope_1126);
            	            s1=statement(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulescope_Ex;
            	            }
            	            if (HASFAILED())
            	            {
            	                return node;
            	            }


            	            if ( BACKTRACKING==0 )
            	            {

            	                                corto_llAppend(node->statements, s1
            	                );
            	                            
            	            }


            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:323:9: INDENT (s2= statement )+ DEDENT
            	    {
            	         MATCHT(INDENT, &FOLLOW_INDENT_in_scope_1170);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescope_Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        // Cortolang.g:324:9: (s2= statement )+
            	        {
            	            int cnt14=0;

            	            for (;;)
            	            {
            	                int alt14=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case CHARACTER:
            	        	case EMARK:
            	        	case GID:
            	        	case INTEGER:
            	        	case KW_BREAK:
            	        	case KW_CONTINUE:
            	        	case KW_FALSE:
            	        	case KW_IF:
            	        	case KW_NOT:
            	        	case KW_ON:
            	        	case KW_TRUE:
            	        	case KW_WHILE:
            	        	case LBRACE:
            	        	case LPAREN:
            	        	case MINUS:
            	        	case NEWLINE:
            	        	case STRING:
            	        	case TILDE:
            	        	case VALID_NAME:
            	        		{
            	        			alt14=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt14)
            	        	{
            	        	    case 1:
            	        	        // Cortolang.g:325:13: s2= statement
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_statement_in_scope_1196);
            	        	            s2=statement(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulescope_Ex;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return node;
            	        	            }


            	        	            if ( BACKTRACKING==0 )
            	        	            {

            	        	                                corto_llAppend(node->statements, s2
            	        	                );
            	        	                            
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt14 >= 1 )
            	        		{
            	        		    goto loop14;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    return node;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulescope_Ex;
            	        	}
            	        	cnt14++;
            	            }
            	            loop14: ;	/* Jump to here if this rule does not match */
            	        }

            	         MATCHT(DEDENT, &FOLLOW_DEDENT_in_scope_1231);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescope_Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                        node->isPostScope = scopeOp8
                ;
                        corto_define(node);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulescope_Ex; /* Prevent compiler warnings */
    rulescope_Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end scope_ */

/**
 * $ANTLR start functionDeclaration
 * Cortolang.g:344:1: functionDeclaration returns [ parser_StatementNode ___ node ] : tl= typeLabel name= VALID_NAME LPAREN params= functionParameters RPAREN ( NEWLINE | EQUAL e= conditionalExpression NEWLINE |b= block ) ;
 */
static parser_StatementNode ___
functionDeclaration(pCortolangParser ctx)
{
    parser_StatementNode ___ node;


    pANTLR3_COMMON_TOKEN    name;
    parser_BaseTypeExpressionNode ___ tl;
    #undef	RETURN_TYPE_tl
    #define	RETURN_TYPE_tl parser_BaseTypeExpressionNode ___

    corto_ll ___ params;
    #undef	RETURN_TYPE_params
    #define	RETURN_TYPE_params corto_ll ___

    parser_ExpressionNode ___ e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e parser_ExpressionNode ___

    parser_StatementNode ___ b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b parser_StatementNode ___

    /* Initialize rule variables
     */


        node = NULL;
        e = NULL;
        b = NULL;

    name       = NULL;

    {
        // Cortolang.g:352:5: (tl= typeLabel name= VALID_NAME LPAREN params= functionParameters RPAREN ( NEWLINE | EQUAL e= conditionalExpression NEWLINE |b= block ) )
        // Cortolang.g:353:5: tl= typeLabel name= VALID_NAME LPAREN params= functionParameters RPAREN ( NEWLINE | EQUAL e= conditionalExpression NEWLINE |b= block )
        {
            FOLLOWPUSH(FOLLOW_typeLabel_in_functionDeclaration1281);
            tl=typeLabel(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            name = (pANTLR3_COMMON_TOKEN) MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_functionDeclaration1289);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return node;
            }


             MATCHT(LPAREN, &FOLLOW_LPAREN_in_functionDeclaration1295);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            FOLLOWPUSH(FOLLOW_functionParameters_in_functionDeclaration1303);
            params=functionParameters(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return node;
            }


             MATCHT(RPAREN, &FOLLOW_RPAREN_in_functionDeclaration1309);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            // Cortolang.g:358:5: ( NEWLINE | EQUAL e= conditionalExpression NEWLINE |b= block )
            {
                int alt16=3;
                switch ( LA(1) )
                {
                case NEWLINE:
                	{
                		alt16=1;
                	}
                    break;
                case EQUAL:
                	{
                		alt16=2;
                	}
                    break;
                case COLON:
                	{
                		alt16=3;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return node;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 16;
                    EXCEPTION->state        = 0;


                    goto rulefunctionDeclarationEx;

                }

                switch (alt16)
                {
            	case 1:
            	    // Cortolang.g:359:9: NEWLINE
            	    {
            	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_functionDeclaration1325);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:361:9: EQUAL e= conditionalExpression NEWLINE
            	    {
            	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_functionDeclaration1345);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_conditionalExpression_in_functionDeclaration1349);
            	        e=conditionalExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_functionDeclaration1351);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;
            	case 3:
            	    // Cortolang.g:363:9: b= block
            	    {
            	        FOLLOWPUSH(FOLLOW_block_in_functionDeclaration1373);
            	        b=block(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                        parser_FunctionDeclarationNode _node = parser_FunctionDeclarationNodeCreate(
                            0, 0, tl
                , CHARS((name->getText(name))), 
                params
                , NULL
                        );
                        if (e
                ) {
                            // TODO create block from single expression
                            _node->block = parser_pw_createBlockFromExpression(e
                );
                        } else {
                            _node->block = parser_BlockNode(b
                );
                        }
                        node = parser_StatementNode(_node);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start functionParameters
 * Cortolang.g:380:1: functionParameters returns [ corto_ll ___ parameters ] : ( (p1= functionParameter ) ( COMMA p2= functionParameter )* )? ;
 */
static corto_ll ___
functionParameters(pCortolangParser ctx)
{
    corto_ll ___ parameters;


    parser_FunctionParameterNode ___ p1;
    #undef	RETURN_TYPE_p1
    #define	RETURN_TYPE_p1 parser_FunctionParameterNode ___

    parser_FunctionParameterNode ___ p2;
    #undef	RETURN_TYPE_p2
    #define	RETURN_TYPE_p2 parser_FunctionParameterNode ___

    /* Initialize rule variables
     */


        parameters = corto_llNew();

    {
        // Cortolang.g:386:5: ( ( (p1= functionParameter ) ( COMMA p2= functionParameter )* )? )
        // Cortolang.g:387:5: ( (p1= functionParameter ) ( COMMA p2= functionParameter )* )?
        {
            // Cortolang.g:387:5: ( (p1= functionParameter ) ( COMMA p2= functionParameter )* )?
            {
                int alt18=2;
                switch ( LA(1) )
                {
                    case GID:
                    case VALID_NAME:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // Cortolang.g:388:9: (p1= functionParameter ) ( COMMA p2= functionParameter )*
            	    {
            	        // Cortolang.g:388:9: (p1= functionParameter )
            	        // Cortolang.g:389:13: p1= functionParameter
            	        {
            	            FOLLOWPUSH(FOLLOW_functionParameter_in_functionParameters1442);
            	            p1=functionParameter(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulefunctionParametersEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return parameters;
            	            }


            	            if ( BACKTRACKING==0 )
            	            {

            	                                corto_llAppend(parameters, p1
            	                );
            	                            
            	            }


            	        }


            	        // Cortolang.g:394:9: ( COMMA p2= functionParameter )*

            	        for (;;)
            	        {
            	            int alt17=2;
            	            switch ( LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt17=1;
            	            	}
            	                break;

            	            }

            	            switch (alt17)
            	            {
            	        	case 1:
            	        	    // Cortolang.g:395:13: COMMA p2= functionParameter
            	        	    {
            	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_functionParameters1490);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefunctionParametersEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return parameters;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_functionParameter_in_functionParameters1506);
            	        	        p2=functionParameter(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefunctionParametersEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return parameters;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {

            	        	                            corto_llAppend(parameters, p2
            	        	            );
            	        	                        
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop17;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop17: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionParametersEx; /* Prevent compiler warnings */
    rulefunctionParametersEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return parameters;
}
/* $ANTLR end functionParameters */

/**
 * $ANTLR start functionParameter
 * Cortolang.g:406:1: functionParameter returns [ parser_FunctionParameterNode ___ node ] : typeLabel VALID_NAME ;
 */
static parser_FunctionParameterNode ___
functionParameter(pCortolangParser ctx)
{
    parser_FunctionParameterNode ___ node;


    pANTLR3_COMMON_TOKEN    VALID_NAME10;
    parser_BaseTypeExpressionNode ___ typeLabel9;
    #undef	RETURN_TYPE_typeLabel9
    #define	RETURN_TYPE_typeLabel9 parser_BaseTypeExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    VALID_NAME10       = NULL;

    {
        // Cortolang.g:412:5: ( typeLabel VALID_NAME )
        // Cortolang.g:413:5: typeLabel VALID_NAME
        {
            FOLLOWPUSH(FOLLOW_typeLabel_in_functionParameter1575);
            typeLabel9=typeLabel(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionParameterEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            VALID_NAME10 = (pANTLR3_COMMON_TOKEN) MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_functionParameter1581);
            if  (HASEXCEPTION())
            {
                goto rulefunctionParameterEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            if ( BACKTRACKING==0 )
            {

                        node = parser_FunctionParameterNodeCreate(
                            0, 0, typeLabel9
                , CHARS((VALID_NAME10->getText(VALID_NAME10)))
                        );
                        corto_claim(node);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionParameterEx; /* Prevent compiler warnings */
    rulefunctionParameterEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end functionParameter */

/**
 * $ANTLR start ifStatement
 * Cortolang.g:429:1: ifStatement : KW_IF expression ( block ) ( ( KW_ELSE )=> ( elseStatement ) )? ;
 */
static void
ifStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:430:5: ( KW_IF expression ( block ) ( ( KW_ELSE )=> ( elseStatement ) )? )
        // Cortolang.g:431:5: KW_IF expression ( block ) ( ( KW_ELSE )=> ( elseStatement ) )?
        {
             MATCHT(KW_IF, &FOLLOW_KW_IF_in_ifStatement1614);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_expression_in_ifStatement1616);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:432:5: ( block )
            // Cortolang.g:433:9: block
            {
                FOLLOWPUSH(FOLLOW_block_in_ifStatement1632);
                block(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleifStatementEx;
                }
                if (HASFAILED())
                {
                    return ;
                }


            }


            // Cortolang.g:435:5: ( ( KW_ELSE )=> ( elseStatement ) )?
            {
                int alt19=2;
                switch ( LA(1) )
                {
                    case KW_ELSE:
                    	{
                    		{
                    		    int LA19_1 = LA(2);
                    		    if ( (synpred5_Cortolang(ctx)))
                    		    {
                    		        alt19=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt19)
                {
            	case 1:
            	    // Cortolang.g:436:9: ( KW_ELSE )=> ( elseStatement )
            	    {
            	        // Cortolang.g:437:9: ( elseStatement )
            	        // Cortolang.g:437:11: elseStatement
            	        {
            	            FOLLOWPUSH(FOLLOW_elseStatement_in_ifStatement1672);
            	            elseStatement(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleifStatementEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start elseStatement
 * Cortolang.g:441:1: elseStatement : KW_ELSE block ;
 */
static void
elseStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:442:5: ( KW_ELSE block )
        // Cortolang.g:443:5: KW_ELSE block
        {
             MATCHT(KW_ELSE, &FOLLOW_KW_ELSE_in_elseStatement1702);
            if  (HASEXCEPTION())
            {
                goto ruleelseStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_block_in_elseStatement1704);
            block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleelseStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleelseStatementEx; /* Prevent compiler warnings */
    ruleelseStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end elseStatement */

/**
 * $ANTLR start whileStatement
 * Cortolang.g:446:1: whileStatement : KW_WHILE expression block ;
 */
static void
whileStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:447:5: ( KW_WHILE expression block )
        // Cortolang.g:448:5: KW_WHILE expression block
        {
             MATCHT(KW_WHILE, &FOLLOW_KW_WHILE_in_whileStatement1725);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_expression_in_whileStatement1727);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_block_in_whileStatement1729);
            block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start breakStatement
 * Cortolang.g:451:1: breakStatement : KW_BREAK ;
 */
static void
breakStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:452:5: ( KW_BREAK )
        // Cortolang.g:453:5: KW_BREAK
        {
             MATCHT(KW_BREAK, &FOLLOW_KW_BREAK_in_breakStatement1750);
            if  (HASEXCEPTION())
            {
                goto rulebreakStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebreakStatementEx; /* Prevent compiler warnings */
    rulebreakStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end breakStatement */

/**
 * $ANTLR start continueStatement
 * Cortolang.g:456:1: continueStatement : KW_CONTINUE ;
 */
static void
continueStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:457:5: ( KW_CONTINUE )
        // Cortolang.g:458:5: KW_CONTINUE
        {
             MATCHT(KW_CONTINUE, &FOLLOW_KW_CONTINUE_in_continueStatement1771);
            if  (HASEXCEPTION())
            {
                goto rulecontinueStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecontinueStatementEx; /* Prevent compiler warnings */
    rulecontinueStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end continueStatement */

/**
 * $ANTLR start expression
 * Cortolang.g:467:1: expression returns [ parser_ExpressionNode ___ node ] : assignmentExpression ;
 */
static parser_ExpressionNode ___
expression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ assignmentExpression11;
    #undef	RETURN_TYPE_assignmentExpression11
    #define	RETURN_TYPE_assignmentExpression11 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:472:5: ( assignmentExpression )
        // Cortolang.g:473:5: assignmentExpression
        {
            FOLLOWPUSH(FOLLOW_assignmentExpression_in_expression1807);
            assignmentExpression11=assignmentExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            if ( BACKTRACKING==0 )
            {

                        node = assignmentExpression11
                ;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end expression */

/**
 * $ANTLR start assignmentExpression
 * Cortolang.g:480:1: assignmentExpression returns [ parser_ExpressionNode ___ node ] : (e1= simpleCommaExpression ) ( (op= assignmentOp ) e2= simpleCommaExpression )? ;
 */
static parser_ExpressionNode ___
assignmentExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    corto_operatorKind ___ ___ op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op corto_operatorKind ___ ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:485:5: ( (e1= simpleCommaExpression ) ( (op= assignmentOp ) e2= simpleCommaExpression )? )
        // Cortolang.g:486:5: (e1= simpleCommaExpression ) ( (op= assignmentOp ) e2= simpleCommaExpression )?
        {
            // Cortolang.g:486:5: (e1= simpleCommaExpression )
            // Cortolang.g:487:9: e1= simpleCommaExpression
            {
                FOLLOWPUSH(FOLLOW_simpleCommaExpression_in_assignmentExpression1856);
                e1=simpleCommaExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleassignmentExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:492:5: ( (op= assignmentOp ) e2= simpleCommaExpression )?
            {
                int alt20=2;
                switch ( LA(1) )
                {
                    case AMP_EQUAL:
                    case COLON_EQUAL:
                    case DIV_EQUAL:
                    case EQUAL:
                    case HAT_EQUAL:
                    case MINUS_EQUAL:
                    case MOD_EQUAL:
                    case PIPE_EQUAL:
                    case PLUS_EQUAL:
                    case TIMES_EQUAL:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20)
                {
            	case 1:
            	    // Cortolang.g:493:9: (op= assignmentOp ) e2= simpleCommaExpression
            	    {
            	        // Cortolang.g:493:9: (op= assignmentOp )
            	        // Cortolang.g:494:13: op= assignmentOp
            	        {
            	            FOLLOWPUSH(FOLLOW_assignmentOp_in_assignmentExpression1904);
            	            op=assignmentOp(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleassignmentExpressionEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return node;
            	            }


            	        }


            	        FOLLOWPUSH(FOLLOW_simpleCommaExpression_in_assignmentExpression1926);
            	        e2=simpleCommaExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleassignmentExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, op
            	            , e2
            	            );
            	                    
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignmentExpressionEx; /* Prevent compiler warnings */
    ruleassignmentExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end assignmentExpression */

/**
 * $ANTLR start simpleCommaExpression
 * Cortolang.g:504:1: simpleCommaExpression returns [ parser_ExpressionNode ___ node ] : (e1= conditionalExpression ) ( COMMA e2= conditionalExpression )* ( COMMA )? ;
 */
static parser_ExpressionNode ___
simpleCommaExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:509:5: ( (e1= conditionalExpression ) ( COMMA e2= conditionalExpression )* ( COMMA )? )
        // Cortolang.g:510:5: (e1= conditionalExpression ) ( COMMA e2= conditionalExpression )* ( COMMA )?
        {
            // Cortolang.g:510:5: (e1= conditionalExpression )
            // Cortolang.g:511:9: e1= conditionalExpression
            {
                FOLLOWPUSH(FOLLOW_conditionalExpression_in_simpleCommaExpression1986);
                e1=conditionalExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesimpleCommaExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:516:5: ( COMMA e2= conditionalExpression )*

            for (;;)
            {
                int alt21=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		switch ( LA(2) )
                		{
                		case CHARACTER:
                		case EMARK:
                		case GID:
                		case INTEGER:
                		case KW_FALSE:
                		case KW_NOT:
                		case KW_TRUE:
                		case LBRACE:
                		case LPAREN:
                		case MINUS:
                		case STRING:
                		case TILDE:
                		case VALID_NAME:
                			{
                				alt21=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt21)
                {
            	case 1:
            	    // Cortolang.g:517:9: COMMA e2= conditionalExpression
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_simpleCommaExpression2018);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimpleCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_conditionalExpression_in_simpleCommaExpression2030);
            	        e2=conditionalExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimpleCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        // TODO would move this method to CustomParser.cpp
            	                        parser_CommaExpressionNode _node;
            	                        if (!corto_instanceof(parser_CommaExpressionNode_o, node)) {
            	                            _node = parser_CommaExpressionNodeCreate(
            	                                0, 0, corto_llNew()
            	                            );
            	                            corto_llAppend(_node->expressions, node);
            	                            node = parser_ExpressionNode(_node);
            	                        } else {
            	                            _node = parser_CommaExpressionNode(node);
            	                        }
            	                        corto_llAppend(_node->expressions, e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */


            // Cortolang.g:534:5: ( COMMA )?
            {
                int alt22=2;
                switch ( LA(1) )
                {
                    case COMMA:
                    	{
                    		alt22=1;
                    	}
                        break;
                }

                switch (alt22)
                {
            	case 1:
            	    // Cortolang.g:534:5: COMMA
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_simpleCommaExpression2053);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimpleCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimpleCommaExpressionEx; /* Prevent compiler warnings */
    rulesimpleCommaExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end simpleCommaExpression */

/**
 * $ANTLR start fullCommaExpression
 * Cortolang.g:541:1: fullCommaExpression returns [ parser_FullCommaExpressionNode ___ node ] : ( (e1= commaExpressionElem ) ( COMMA e2= commaExpressionElem )* ( COMMA )? )? ;
 */
static parser_FullCommaExpressionNode ___
fullCommaExpression(pCortolangParser ctx)
{
    parser_FullCommaExpressionNode ___ node;


    parser_FullCommaExpressionElementNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_FullCommaExpressionElementNode ___

    parser_FullCommaExpressionElementNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_FullCommaExpressionElementNode ___

    /* Initialize rule variables
     */


        node = parser_FullCommaExpressionNodeDeclare();
        node->elements = corto_llNew();

    {
        // Cortolang.g:547:5: ( ( (e1= commaExpressionElem ) ( COMMA e2= commaExpressionElem )* ( COMMA )? )? )
        // Cortolang.g:548:5: ( (e1= commaExpressionElem ) ( COMMA e2= commaExpressionElem )* ( COMMA )? )?
        {
            // Cortolang.g:548:5: ( (e1= commaExpressionElem ) ( COMMA e2= commaExpressionElem )* ( COMMA )? )?
            {
                int alt25=2;
                switch ( LA(1) )
                {
                    case CHARACTER:
                    case EMARK:
                    case GID:
                    case INTEGER:
                    case KW_FALSE:
                    case KW_NOT:
                    case KW_TRUE:
                    case LBRACE:
                    case LPAREN:
                    case MINUS:
                    case STRING:
                    case TILDE:
                    case VALID_NAME:
                    	{
                    		alt25=1;
                    	}
                        break;
                }

                switch (alt25)
                {
            	case 1:
            	    // Cortolang.g:549:9: (e1= commaExpressionElem ) ( COMMA e2= commaExpressionElem )* ( COMMA )?
            	    {
            	        // Cortolang.g:549:9: (e1= commaExpressionElem )
            	        // Cortolang.g:550:13: e1= commaExpressionElem
            	        {
            	            FOLLOWPUSH(FOLLOW_commaExpressionElem_in_fullCommaExpression2113);
            	            e1=commaExpressionElem(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulefullCommaExpressionEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return node;
            	            }


            	            if ( BACKTRACKING==0 )
            	            {

            	                                corto_llAppend(node->elements, e1
            	                );
            	                            
            	            }


            	        }


            	        // Cortolang.g:555:9: ( COMMA e2= commaExpressionElem )*

            	        for (;;)
            	        {
            	            int alt23=2;
            	            switch ( LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case CHARACTER:
            	            		case EMARK:
            	            		case GID:
            	            		case INTEGER:
            	            		case KW_FALSE:
            	            		case KW_NOT:
            	            		case KW_TRUE:
            	            		case LBRACE:
            	            		case LPAREN:
            	            		case MINUS:
            	            		case STRING:
            	            		case TILDE:
            	            		case VALID_NAME:
            	            			{
            	            				alt23=1;
            	            			}
            	            		    break;

            	            		}

            	            	}
            	                break;

            	            }

            	            switch (alt23)
            	            {
            	        	case 1:
            	        	    // Cortolang.g:556:13: COMMA e2= commaExpressionElem
            	        	    {
            	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_fullCommaExpression2161);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefullCommaExpressionEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return node;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_commaExpressionElem_in_fullCommaExpression2177);
            	        	        e2=commaExpressionElem(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefullCommaExpressionEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return node;
            	        	        }


            	        	        if ( BACKTRACKING==0 )
            	        	        {

            	        	                            corto_llAppend(node->elements, e2
            	        	            );
            	        	                        
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop23;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop23: ; /* Jump out to here if this rule does not match */


            	        // Cortolang.g:562:9: ( COMMA )?
            	        {
            	            int alt24=2;
            	            switch ( LA(1) )
            	            {
            	                case COMMA:
            	                	{
            	                		alt24=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt24)
            	            {
            	        	case 1:
            	        	    // Cortolang.g:562:9: COMMA
            	        	    {
            	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_fullCommaExpression2212);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefullCommaExpressionEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return node;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                        corto_define(node);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefullCommaExpressionEx; /* Prevent compiler warnings */
    rulefullCommaExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end fullCommaExpression */

/**
 * $ANTLR start commaExpressionElem
 * Cortolang.g:570:1: commaExpressionElem returns [ parser_FullCommaExpressionElementNode ___ node ] : (e1= conditionalExpression ) ( EQUAL e2= conditionalExpression )? ;
 */
static parser_FullCommaExpressionElementNode ___
commaExpressionElem(pCortolangParser ctx)
{
    parser_FullCommaExpressionElementNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;
        e1 = NULL;
        e2 = NULL;

    {
        // Cortolang.g:577:5: ( (e1= conditionalExpression ) ( EQUAL e2= conditionalExpression )? )
        // Cortolang.g:578:5: (e1= conditionalExpression ) ( EQUAL e2= conditionalExpression )?
        {
            // Cortolang.g:578:5: (e1= conditionalExpression )
            // Cortolang.g:579:9: e1= conditionalExpression
            {
                FOLLOWPUSH(FOLLOW_conditionalExpression_in_commaExpressionElem2269);
                e1=conditionalExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulecommaExpressionElemEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


            }


            // Cortolang.g:581:5: ( EQUAL e2= conditionalExpression )?
            {
                int alt26=2;
                switch ( LA(1) )
                {
                    case EQUAL:
                    	{
                    		alt26=1;
                    	}
                        break;
                }

                switch (alt26)
                {
            	case 1:
            	    // Cortolang.g:582:9: EQUAL e2= conditionalExpression
            	    {
            	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_commaExpressionElem2291);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommaExpressionElemEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_conditionalExpression_in_commaExpressionElem2303);
            	        e2=conditionalExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommaExpressionElemEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                        if (e2
                ) {
                            node = parser_FullCommaExpressionElementNodeCreate(
                                0, 0, e1
                , e2

                            );
                        } else {
                            node = parser_FullCommaExpressionElementNodeCreate(
                                0, 0, NULL, e1

                            );
                        }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecommaExpressionElemEx; /* Prevent compiler warnings */
    rulecommaExpressionElemEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end commaExpressionElem */

/**
 * $ANTLR start conditionalExpression
 * Cortolang.g:599:1: conditionalExpression returns [ parser_ExpressionNode ___ node ] : (e1= logicOrExpression ) ( QMARK e2= logicOrExpression COLON e3= logicOrExpression )? ;
 */
static parser_ExpressionNode ___
conditionalExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    parser_ExpressionNode ___ e3;
    #undef	RETURN_TYPE_e3
    #define	RETURN_TYPE_e3 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = parser_ExpressionNodeCreate(0, 0);

    {
        // Cortolang.g:604:5: ( (e1= logicOrExpression ) ( QMARK e2= logicOrExpression COLON e3= logicOrExpression )? )
        // Cortolang.g:605:5: (e1= logicOrExpression ) ( QMARK e2= logicOrExpression COLON e3= logicOrExpression )?
        {
            // Cortolang.g:605:5: (e1= logicOrExpression )
            // Cortolang.g:606:9: e1= logicOrExpression
            {
                FOLLOWPUSH(FOLLOW_logicOrExpression_in_conditionalExpression2359);
                e1=logicOrExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleconditionalExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:611:5: ( QMARK e2= logicOrExpression COLON e3= logicOrExpression )?
            {
                int alt27=2;
                switch ( LA(1) )
                {
                    case QMARK:
                    	{
                    		alt27=1;
                    	}
                        break;
                }

                switch (alt27)
                {
            	case 1:
            	    // Cortolang.g:612:9: QMARK e2= logicOrExpression COLON e3= logicOrExpression
            	    {
            	         MATCHT(QMARK, &FOLLOW_QMARK_in_conditionalExpression2391);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_logicOrExpression_in_conditionalExpression2403);
            	        e2=logicOrExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	         MATCHT(COLON, &FOLLOW_COLON_in_conditionalExpression2413);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_logicOrExpression_in_conditionalExpression2425);
            	        e3=logicOrExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        parser_ConditionalExpressionNode _node = parser_ConditionalExpressionNodeCreate(
            	                            0, 0, node, e2
            	            , e3

            	                        );
            	                        node = parser_ExpressionNode(_node);
            	                    
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconditionalExpressionEx; /* Prevent compiler warnings */
    ruleconditionalExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end conditionalExpression */

/**
 * $ANTLR start logicOrExpression
 * Cortolang.g:626:1: logicOrExpression returns [ parser_ExpressionNode ___ node ] : (e1= logicAndExpression ) ( KW_OR e2= logicAndExpression )* ;
 */
static parser_ExpressionNode ___
logicOrExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:631:5: ( (e1= logicAndExpression ) ( KW_OR e2= logicAndExpression )* )
        // Cortolang.g:632:5: (e1= logicAndExpression ) ( KW_OR e2= logicAndExpression )*
        {
            // Cortolang.g:632:5: (e1= logicAndExpression )
            // Cortolang.g:633:9: e1= logicAndExpression
            {
                FOLLOWPUSH(FOLLOW_logicAndExpression_in_logicOrExpression2485);
                e1=logicAndExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulelogicOrExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:638:5: ( KW_OR e2= logicAndExpression )*

            for (;;)
            {
                int alt28=2;
                switch ( LA(1) )
                {
                case KW_OR:
                	{
                		alt28=1;
                	}
                    break;

                }

                switch (alt28)
                {
            	case 1:
            	    // Cortolang.g:639:9: KW_OR e2= logicAndExpression
            	    {
            	         MATCHT(KW_OR, &FOLLOW_KW_OR_in_logicOrExpression2517);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogicOrExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_logicAndExpression_in_logicOrExpression2529);
            	        e2=logicAndExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogicOrExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, CORTO_COND_OR, e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop28;	/* break out of the loop */
            	    break;
                }
            }
            loop28: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelogicOrExpressionEx; /* Prevent compiler warnings */
    rulelogicOrExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end logicOrExpression */

/**
 * $ANTLR start logicAndExpression
 * Cortolang.g:648:1: logicAndExpression returns [ parser_ExpressionNode ___ node ] : (e1= equalityExpression ) ( KW_AND e2= equalityExpression )* ;
 */
static parser_ExpressionNode ___
logicAndExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:653:5: ( (e1= equalityExpression ) ( KW_AND e2= equalityExpression )* )
        // Cortolang.g:654:5: (e1= equalityExpression ) ( KW_AND e2= equalityExpression )*
        {
            // Cortolang.g:654:5: (e1= equalityExpression )
            // Cortolang.g:655:9: e1= equalityExpression
            {
                FOLLOWPUSH(FOLLOW_equalityExpression_in_logicAndExpression2589);
                e1=equalityExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulelogicAndExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:660:5: ( KW_AND e2= equalityExpression )*

            for (;;)
            {
                int alt29=2;
                switch ( LA(1) )
                {
                case KW_AND:
                	{
                		alt29=1;
                	}
                    break;

                }

                switch (alt29)
                {
            	case 1:
            	    // Cortolang.g:661:9: KW_AND e2= equalityExpression
            	    {
            	         MATCHT(KW_AND, &FOLLOW_KW_AND_in_logicAndExpression2621);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogicAndExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_equalityExpression_in_logicAndExpression2633);
            	        e2=equalityExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogicAndExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, CORTO_COND_AND, e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop29;	/* break out of the loop */
            	    break;
                }
            }
            loop29: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelogicAndExpressionEx; /* Prevent compiler warnings */
    rulelogicAndExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end logicAndExpression */

/**
 * $ANTLR start equalityExpression
 * Cortolang.g:670:1: equalityExpression returns [ parser_ExpressionNode ___ node ] : (e1= comparisonExpression ) (op= eqOp e2= comparisonExpression )? ;
 */
static parser_ExpressionNode ___
equalityExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    corto_operatorKind ___ op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op corto_operatorKind ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:675:5: ( (e1= comparisonExpression ) (op= eqOp e2= comparisonExpression )? )
        // Cortolang.g:676:5: (e1= comparisonExpression ) (op= eqOp e2= comparisonExpression )?
        {
            // Cortolang.g:676:5: (e1= comparisonExpression )
            // Cortolang.g:677:9: e1= comparisonExpression
            {
                FOLLOWPUSH(FOLLOW_comparisonExpression_in_equalityExpression2693);
                e1=comparisonExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleequalityExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:682:5: (op= eqOp e2= comparisonExpression )?
            {
                int alt30=2;
                switch ( LA(1) )
                {
                    case EQUALS:
                    case NOT_EQUALS:
                    	{
                    		alt30=1;
                    	}
                        break;
                }

                switch (alt30)
                {
            	case 1:
            	    // Cortolang.g:683:9: op= eqOp e2= comparisonExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_eqOp_in_equalityExpression2727);
            	        op=eqOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequalityExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_comparisonExpression_in_equalityExpression2739);
            	        e2=comparisonExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequalityExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, op
            	            , e2
            	            );
            	                    
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleequalityExpressionEx; /* Prevent compiler warnings */
    ruleequalityExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end equalityExpression */

/**
 * $ANTLR start comparisonExpression
 * Cortolang.g:692:1: comparisonExpression returns [ parser_ExpressionNode ___ node ] : (e1= bitOrExpression ) (op= comparisonOp e2= bitOrExpression )? ;
 */
static parser_ExpressionNode ___
comparisonExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    corto_operatorKind ___ op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op corto_operatorKind ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:697:5: ( (e1= bitOrExpression ) (op= comparisonOp e2= bitOrExpression )? )
        // Cortolang.g:698:5: (e1= bitOrExpression ) (op= comparisonOp e2= bitOrExpression )?
        {
            // Cortolang.g:698:5: (e1= bitOrExpression )
            // Cortolang.g:699:9: e1= bitOrExpression
            {
                FOLLOWPUSH(FOLLOW_bitOrExpression_in_comparisonExpression2799);
                e1=bitOrExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulecomparisonExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:704:5: (op= comparisonOp e2= bitOrExpression )?
            {
                int alt31=2;
                switch ( LA(1) )
                {
                    case GREATER_THAN:
                    case GREATER_THAN_EQUAL:
                    case LESS_THAN:
                    case LESS_THAN_EQUAL:
                    	{
                    		alt31=1;
                    	}
                        break;
                }

                switch (alt31)
                {
            	case 1:
            	    // Cortolang.g:705:9: op= comparisonOp e2= bitOrExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_comparisonOp_in_comparisonExpression2833);
            	        op=comparisonOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomparisonExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_bitOrExpression_in_comparisonExpression2845);
            	        e2=bitOrExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomparisonExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, op
            	            , e2
            	            );
            	                    
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecomparisonExpressionEx; /* Prevent compiler warnings */
    rulecomparisonExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end comparisonExpression */

/**
 * $ANTLR start bitOrExpression
 * Cortolang.g:714:1: bitOrExpression returns [ parser_ExpressionNode ___ node ] : (e1= bitXorExpression ) ( PIPE e2= bitXorExpression )* ;
 */
static parser_ExpressionNode ___
bitOrExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:719:5: ( (e1= bitXorExpression ) ( PIPE e2= bitXorExpression )* )
        // Cortolang.g:720:5: (e1= bitXorExpression ) ( PIPE e2= bitXorExpression )*
        {
            // Cortolang.g:720:5: (e1= bitXorExpression )
            // Cortolang.g:721:9: e1= bitXorExpression
            {
                FOLLOWPUSH(FOLLOW_bitXorExpression_in_bitOrExpression2905);
                e1=bitXorExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulebitOrExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:726:5: ( PIPE e2= bitXorExpression )*

            for (;;)
            {
                int alt32=2;
                switch ( LA(1) )
                {
                case PIPE:
                	{
                		alt32=1;
                	}
                    break;

                }

                switch (alt32)
                {
            	case 1:
            	    // Cortolang.g:727:9: PIPE e2= bitXorExpression
            	    {
            	         MATCHT(PIPE, &FOLLOW_PIPE_in_bitOrExpression2937);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitOrExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_bitXorExpression_in_bitOrExpression2949);
            	        e2=bitXorExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitOrExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, CORTO_OR, e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop32;	/* break out of the loop */
            	    break;
                }
            }
            loop32: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebitOrExpressionEx; /* Prevent compiler warnings */
    rulebitOrExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end bitOrExpression */

/**
 * $ANTLR start bitXorExpression
 * Cortolang.g:736:1: bitXorExpression returns [ parser_ExpressionNode ___ node ] : (e1= bitAndExpression ) ( HAT e2= bitAndExpression )* ;
 */
static parser_ExpressionNode ___
bitXorExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:741:5: ( (e1= bitAndExpression ) ( HAT e2= bitAndExpression )* )
        // Cortolang.g:742:5: (e1= bitAndExpression ) ( HAT e2= bitAndExpression )*
        {
            // Cortolang.g:742:5: (e1= bitAndExpression )
            // Cortolang.g:743:9: e1= bitAndExpression
            {
                FOLLOWPUSH(FOLLOW_bitAndExpression_in_bitXorExpression3009);
                e1=bitAndExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulebitXorExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:748:5: ( HAT e2= bitAndExpression )*

            for (;;)
            {
                int alt33=2;
                switch ( LA(1) )
                {
                case HAT:
                	{
                		alt33=1;
                	}
                    break;

                }

                switch (alt33)
                {
            	case 1:
            	    // Cortolang.g:749:9: HAT e2= bitAndExpression
            	    {
            	         MATCHT(HAT, &FOLLOW_HAT_in_bitXorExpression3041);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitXorExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_bitAndExpression_in_bitXorExpression3053);
            	        e2=bitAndExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitXorExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, CORTO_XOR, e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop33;	/* break out of the loop */
            	    break;
                }
            }
            loop33: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebitXorExpressionEx; /* Prevent compiler warnings */
    rulebitXorExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end bitXorExpression */

/**
 * $ANTLR start bitAndExpression
 * Cortolang.g:758:1: bitAndExpression returns [ parser_ExpressionNode ___ node ] : (e1= shiftExpression ) ( AMPERSAND e2= shiftExpression )* ;
 */
static parser_ExpressionNode ___
bitAndExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:763:5: ( (e1= shiftExpression ) ( AMPERSAND e2= shiftExpression )* )
        // Cortolang.g:764:5: (e1= shiftExpression ) ( AMPERSAND e2= shiftExpression )*
        {
            // Cortolang.g:764:5: (e1= shiftExpression )
            // Cortolang.g:765:9: e1= shiftExpression
            {
                FOLLOWPUSH(FOLLOW_shiftExpression_in_bitAndExpression3113);
                e1=shiftExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulebitAndExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:770:5: ( AMPERSAND e2= shiftExpression )*

            for (;;)
            {
                int alt34=2;
                switch ( LA(1) )
                {
                case AMPERSAND:
                	{
                		alt34=1;
                	}
                    break;

                }

                switch (alt34)
                {
            	case 1:
            	    // Cortolang.g:771:9: AMPERSAND e2= shiftExpression
            	    {
            	         MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_bitAndExpression3145);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitAndExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_shiftExpression_in_bitAndExpression3157);
            	        e2=shiftExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitAndExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, CORTO_AND, e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop34;	/* break out of the loop */
            	    break;
                }
            }
            loop34: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebitAndExpressionEx; /* Prevent compiler warnings */
    rulebitAndExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end bitAndExpression */

/**
 * $ANTLR start shiftExpression
 * Cortolang.g:780:1: shiftExpression returns [ parser_ExpressionNode ___ node ] : (e1= addExpression ) (op= shiftOp e2= addExpression )* ;
 */
static parser_ExpressionNode ___
shiftExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    corto_operatorKind ___ op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op corto_operatorKind ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:785:5: ( (e1= addExpression ) (op= shiftOp e2= addExpression )* )
        // Cortolang.g:786:5: (e1= addExpression ) (op= shiftOp e2= addExpression )*
        {
            // Cortolang.g:786:5: (e1= addExpression )
            // Cortolang.g:787:9: e1= addExpression
            {
                FOLLOWPUSH(FOLLOW_addExpression_in_shiftExpression3217);
                e1=addExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleshiftExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:792:5: (op= shiftOp e2= addExpression )*

            for (;;)
            {
                int alt35=2;
                switch ( LA(1) )
                {
                case LSHIFT:
                case RSHIFT:
                	{
                		alt35=1;
                	}
                    break;

                }

                switch (alt35)
                {
            	case 1:
            	    // Cortolang.g:793:9: op= shiftOp e2= addExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_shiftOp_in_shiftExpression3251);
            	        op=shiftOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleshiftExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_addExpression_in_shiftExpression3263);
            	        e2=addExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleshiftExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, op
            	            , e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop35;	/* break out of the loop */
            	    break;
                }
            }
            loop35: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleshiftExpressionEx; /* Prevent compiler warnings */
    ruleshiftExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end shiftExpression */

/**
 * $ANTLR start addExpression
 * Cortolang.g:802:1: addExpression returns [ parser_ExpressionNode ___ node ] : (e1= multExpression ) ( ( addOp multExpression )=>op= addOp e2= multExpression )* ;
 */
static parser_ExpressionNode ___
addExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    corto_operatorKind ___ op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op corto_operatorKind ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = parser_ExpressionNodeCreate(0, 0);

    {
        // Cortolang.g:807:5: ( (e1= multExpression ) ( ( addOp multExpression )=>op= addOp e2= multExpression )* )
        // Cortolang.g:808:5: (e1= multExpression ) ( ( addOp multExpression )=>op= addOp e2= multExpression )*
        {
            // Cortolang.g:808:5: (e1= multExpression )
            // Cortolang.g:809:9: e1= multExpression
            {
                FOLLOWPUSH(FOLLOW_multExpression_in_addExpression3323);
                e1=multExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleaddExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:814:5: ( ( addOp multExpression )=>op= addOp e2= multExpression )*

            for (;;)
            {
                int alt36=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA36_0 = LA(1);
                    if ( (synpred6_Cortolang(ctx)) && (LA36_0 == PLUS))
                    {
                        alt36=1;
                    }
                    else if ( (synpred6_Cortolang(ctx)) && (LA36_0 == MINUS))
                    {
                        alt36=1;
                    }

                }
                switch (alt36)
                {
            	case 1:
            	    // Cortolang.g:815:9: ( addOp multExpression )=>op= addOp e2= multExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_addOp_in_addExpression3373);
            	        op=addOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_multExpression_in_addExpression3385);
            	        e2=multExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, op
            	            , e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop36;	/* break out of the loop */
            	    break;
                }
            }
            loop36: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddExpressionEx; /* Prevent compiler warnings */
    ruleaddExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end addExpression */

/**
 * $ANTLR start multExpression
 * Cortolang.g:825:1: multExpression returns [ parser_ExpressionNode ___ node ] : (e1= unaryExpression ) (op= multOp e2= unaryExpression )* ;
 */
static parser_ExpressionNode ___
multExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    corto_operatorKind ___ op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op corto_operatorKind ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:830:5: ( (e1= unaryExpression ) (op= multOp e2= unaryExpression )* )
        // Cortolang.g:831:5: (e1= unaryExpression ) (op= multOp e2= unaryExpression )*
        {
            // Cortolang.g:831:5: (e1= unaryExpression )
            // Cortolang.g:832:9: e1= unaryExpression
            {
                FOLLOWPUSH(FOLLOW_unaryExpression_in_multExpression3445);
                e1=unaryExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulemultExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:837:5: (op= multOp e2= unaryExpression )*

            for (;;)
            {
                int alt37=2;
                switch ( LA(1) )
                {
                case ASTERISK:
                case SLASH:
                	{
                		alt37=1;
                	}
                    break;

                }

                switch (alt37)
                {
            	case 1:
            	    // Cortolang.g:838:9: op= multOp e2= unaryExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_multOp_in_multExpression3479);
            	        op=multOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_unaryExpression_in_multExpression3491);
            	        e2=unaryExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_pw_createBinaryExpression(node, op
            	            , e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultExpressionEx; /* Prevent compiler warnings */
    rulemultExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end multExpression */

/**
 * $ANTLR start unaryExpression
 * Cortolang.g:847:1: unaryExpression returns [ parser_ExpressionNode ___ node ] : (op= unaryOp )? e= postfixExpression ;
 */
static parser_ExpressionNode ___
unaryExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    corto_operatorKind ___ op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op corto_operatorKind ___

    parser_ExpressionNode ___ e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;
        op = (corto_operatorKind)0; /* 0 is CORTO_ASSIGN, which doesn't otherwise make sense here */
        e = NULL;

    {
        // Cortolang.g:855:5: ( (op= unaryOp )? e= postfixExpression )
        // Cortolang.g:856:5: (op= unaryOp )? e= postfixExpression
        {
            // Cortolang.g:856:7: (op= unaryOp )?
            {
                int alt38=2;
                switch ( LA(1) )
                {
                    case EMARK:
                    case KW_NOT:
                    case MINUS:
                    case TILDE:
                    	{
                    		alt38=1;
                    	}
                        break;
                }

                switch (alt38)
                {
            	case 1:
            	    // Cortolang.g:856:7: op= unaryOp
            	    {
            	        FOLLOWPUSH(FOLLOW_unaryOp_in_unaryExpression3541);
            	        op=unaryOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunaryExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_postfixExpression_in_unaryExpression3546);
            e=postfixExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleunaryExpressionEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            if ( BACKTRACKING==0 )
            {

                        if (op
                ) {
                            parser_UnaryExpressionNode _node = parser_UnaryExpressionNodeCreate(
                                0, 0, op
                , e

                            );
                            node = parser_ExpressionNode(_node);
                        } else {
                            node = e
                ;
                        }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunaryExpressionEx; /* Prevent compiler warnings */
    ruleunaryExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end unaryExpression */

/**
 * $ANTLR start postfixExpression
 * Cortolang.g:870:1: postfixExpression returns [ parser_ExpressionNode ___ node ] : (e= atomExpression ) ( postfixOperation[ node ] )* ;
 */
static parser_ExpressionNode ___
postfixExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e parser_ExpressionNode ___

    parser_ExpressionNode ___ postfixOperation12;
    #undef	RETURN_TYPE_postfixOperation12
    #define	RETURN_TYPE_postfixOperation12 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:876:5: ( (e= atomExpression ) ( postfixOperation[ node ] )* )
        // Cortolang.g:877:5: (e= atomExpression ) ( postfixOperation[ node ] )*
        {
            // Cortolang.g:877:5: (e= atomExpression )
            // Cortolang.g:878:9: e= atomExpression
            {
                FOLLOWPUSH(FOLLOW_atomExpression_in_postfixExpression3595);
                e=atomExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulepostfixExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e
                    ;
                            
                }


            }


            // Cortolang.g:883:5: ( postfixOperation[ node ] )*

            for (;;)
            {
                int alt39=2;
                switch ( LA(1) )
                {
                case DOT:
                case LBRACK:
                case LPAREN:
                	{
                		alt39=1;
                	}
                    break;

                }

                switch (alt39)
                {
            	case 1:
            	    // Cortolang.g:884:9: postfixOperation[ node ]
            	    {
            	        FOLLOWPUSH(FOLLOW_postfixOperation_in_postfixExpression3627);
            	        postfixOperation12=postfixOperation(ctx, node);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = postfixOperation12
            	            ;
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop39;	/* break out of the loop */
            	    break;
                }
            }
            loop39: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepostfixExpressionEx; /* Prevent compiler warnings */
    rulepostfixExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end postfixExpression */

/**
 * $ANTLR start atomExpression
 * Cortolang.g:892:1: atomExpression returns [ parser_ExpressionNode ___ node ] : ( literal | identifier | LPAREN e= expression RPAREN | anonymousObject );
 */
static parser_ExpressionNode ___
atomExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e parser_ExpressionNode ___

    parser_LiteralNode ___ literal13;
    #undef	RETURN_TYPE_literal13
    #define	RETURN_TYPE_literal13 parser_LiteralNode ___

    CortolangParser_identifier_return identifier14;
    #undef	RETURN_TYPE_identifier14
    #define	RETURN_TYPE_identifier14 CortolangParser_identifier_return

    /* Initialize rule variables
     */


        node = NULL;

    {
        {
            //  Cortolang.g:898:5: ( literal | identifier | LPAREN e= expression RPAREN | anonymousObject )

            ANTLR3_UINT32 alt40;

            alt40=4;

            switch ( LA(1) )
            {
            case CHARACTER:
            case INTEGER:
            case KW_FALSE:
            case KW_TRUE:
            case STRING:
            	{
            		alt40=1;
            	}
                break;
            case GID:
            case VALID_NAME:
            	{
            		alt40=2;
            	}
                break;
            case LPAREN:
            	{
            		alt40=3;
            	}
                break;
            case LBRACE:
            	{
            		alt40=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return node;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 40;
                EXCEPTION->state        = 0;


                goto ruleatomExpressionEx;

            }

            switch (alt40)
            {
        	case 1:
        	    // Cortolang.g:899:5: literal
        	    {
        	        FOLLOWPUSH(FOLLOW_literal_in_atomExpression3677);
        	        literal13=literal(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = parser_ExpressionNode(literal13
        	            );
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:904:5: identifier
        	    {
        	        FOLLOWPUSH(FOLLOW_identifier_in_atomExpression3695);
        	        identifier14=identifier(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    parser_IdentifierNode _node = parser_IdentifierNodeCreate(0, 0, CHARS((STRSTREAM->toStringTT(STRSTREAM, identifier14.start, identifier14.stop))
        	            ));
        	                    node = parser_ExpressionNode(_node);
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:910:5: LPAREN e= expression RPAREN
        	    {
        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_atomExpression3713);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_atomExpression3717);
        	        e=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_atomExpression3719);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = e
        	            ;
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:915:5: anonymousObject
        	    {
        	        FOLLOWPUSH(FOLLOW_anonymousObject_in_atomExpression3737);
        	        anonymousObject(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomExpressionEx; /* Prevent compiler warnings */
    ruleatomExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end atomExpression */

/**
 * $ANTLR start anonymousObject
 * Cortolang.g:918:1: anonymousObject : LBRACE fullCommaExpression RBRACE ;
 */
static void
anonymousObject(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:919:5: ( LBRACE fullCommaExpression RBRACE )
        // Cortolang.g:920:5: LBRACE fullCommaExpression RBRACE
        {
             MATCHT(LBRACE, &FOLLOW_LBRACE_in_anonymousObject3758);
            if  (HASEXCEPTION())
            {
                goto ruleanonymousObjectEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_fullCommaExpression_in_anonymousObject3760);
            fullCommaExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleanonymousObjectEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(RBRACE, &FOLLOW_RBRACE_in_anonymousObject3762);
            if  (HASEXCEPTION())
            {
                goto ruleanonymousObjectEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleanonymousObjectEx; /* Prevent compiler warnings */
    ruleanonymousObjectEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end anonymousObject */

/**
 * $ANTLR start observerStatement
 * Cortolang.g:927:1: observerStatement : KW_ON eventMask expression ( block | NEWLINE ) ;
 */
static void
observerStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:928:5: ( KW_ON eventMask expression ( block | NEWLINE ) )
        // Cortolang.g:929:5: KW_ON eventMask expression ( block | NEWLINE )
        {
             MATCHT(KW_ON, &FOLLOW_KW_ON_in_observerStatement3787);
            if  (HASEXCEPTION())
            {
                goto ruleobserverStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_eventMask_in_observerStatement3789);
            eventMask(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobserverStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_expression_in_observerStatement3791);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobserverStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:929:32: ( block | NEWLINE )
            {
                int alt41=2;
                switch ( LA(1) )
                {
                case COLON:
                	{
                		alt41=1;
                	}
                    break;
                case NEWLINE:
                	{
                		alt41=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 41;
                    EXCEPTION->state        = 0;


                    goto ruleobserverStatementEx;

                }

                switch (alt41)
                {
            	case 1:
            	    // Cortolang.g:929:34: block
            	    {
            	        FOLLOWPUSH(FOLLOW_block_in_observerStatement3795);
            	        block(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobserverStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:929:42: NEWLINE
            	    {
            	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_observerStatement3799);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobserverStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleobserverStatementEx; /* Prevent compiler warnings */
    ruleobserverStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end observerStatement */

/**
 * $ANTLR start eventMask
 * Cortolang.g:932:1: eventMask : eventFlag ( PIPE eventFlag )* ;
 */
static void
eventMask(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:933:5: ( eventFlag ( PIPE eventFlag )* )
        // Cortolang.g:934:5: eventFlag ( PIPE eventFlag )*
        {
            FOLLOWPUSH(FOLLOW_eventFlag_in_eventMask3822);
            eventFlag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleeventMaskEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:934:15: ( PIPE eventFlag )*

            for (;;)
            {
                int alt42=2;
                switch ( LA(1) )
                {
                case PIPE:
                	{
                		alt42=1;
                	}
                    break;

                }

                switch (alt42)
                {
            	case 1:
            	    // Cortolang.g:934:17: PIPE eventFlag
            	    {
            	         MATCHT(PIPE, &FOLLOW_PIPE_in_eventMask3826);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleeventMaskEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_eventFlag_in_eventMask3828);
            	        eventFlag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleeventMaskEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleeventMaskEx; /* Prevent compiler warnings */
    ruleeventMaskEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eventMask */

/**
 * $ANTLR start eventFlag
 * Cortolang.g:937:1: eventFlag : ( eventBaseFlag | eventScopeFlag );
 */
static void
eventFlag(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:937:11: ( eventBaseFlag | eventScopeFlag )

            ANTLR3_UINT32 alt43;

            alt43=2;

            switch ( LA(1) )
            {
            case KW_DECLARE:
            case KW_DEFINE:
            case KW_DESTRUCT:
            case KW_UPDATE:
            	{
            		alt43=1;
            	}
                break;
            case KW_SCOPE:
            case KW_SELF:
            case KW_SYNCHRONIZED:
            case KW_TREE:
            	{
            		alt43=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 43;
                EXCEPTION->state        = 0;


                goto ruleeventFlagEx;

            }

            switch (alt43)
            {
        	case 1:
        	    // Cortolang.g:937:13: eventBaseFlag
        	    {
        	        FOLLOWPUSH(FOLLOW_eventBaseFlag_in_eventFlag3844);
        	        eventBaseFlag(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleeventFlagEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:937:29: eventScopeFlag
        	    {
        	        FOLLOWPUSH(FOLLOW_eventScopeFlag_in_eventFlag3848);
        	        eventScopeFlag(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleeventFlagEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleeventFlagEx; /* Prevent compiler warnings */
    ruleeventFlagEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eventFlag */

/**
 * $ANTLR start eventBaseFlag
 * Cortolang.g:941:1: eventBaseFlag : ( KW_DECLARE | KW_DEFINE | KW_UPDATE | KW_DESTRUCT );
 */
static void
eventBaseFlag(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:941:15: ( KW_DECLARE | KW_DEFINE | KW_UPDATE | KW_DESTRUCT )
        // Cortolang.g:
        {
            if ( ((LA(1) >= KW_DECLARE) && (LA(1) <= KW_DESTRUCT)) || LA(1) == KW_UPDATE )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleeventBaseFlagEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleeventBaseFlagEx; /* Prevent compiler warnings */
    ruleeventBaseFlagEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eventBaseFlag */

/**
 * $ANTLR start eventScopeFlag
 * Cortolang.g:943:1: eventScopeFlag : ( KW_SELF | KW_SCOPE | KW_TREE | KW_SYNCHRONIZED );
 */
static void
eventScopeFlag(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:943:16: ( KW_SELF | KW_SCOPE | KW_TREE | KW_SYNCHRONIZED )
        // Cortolang.g:
        {
            if ( ((LA(1) >= KW_SCOPE) && (LA(1) <= KW_TREE)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleeventScopeFlagEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleeventScopeFlagEx; /* Prevent compiler warnings */
    ruleeventScopeFlagEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eventScopeFlag */

/**
 * $ANTLR start assignmentOp
 * Cortolang.g:951:1: assignmentOp returns [ corto_operatorKind ___ ___ kind ] : ( EQUAL | PLUS_EQUAL | MINUS_EQUAL | TIMES_EQUAL | DIV_EQUAL | MOD_EQUAL | HAT_EQUAL | PIPE_EQUAL | AMP_EQUAL | COLON_EQUAL );
 */
static corto_operatorKind ___ ___
assignmentOp(pCortolangParser ctx)
{
    corto_operatorKind ___ ___ kind;


    /* Initialize rule variables
     */


        kind = CORTO_ASSIGN;

    {
        {
            //  Cortolang.g:957:5: ( EQUAL | PLUS_EQUAL | MINUS_EQUAL | TIMES_EQUAL | DIV_EQUAL | MOD_EQUAL | HAT_EQUAL | PIPE_EQUAL | AMP_EQUAL | COLON_EQUAL )

            ANTLR3_UINT32 alt44;

            alt44=10;

            switch ( LA(1) )
            {
            case EQUAL:
            	{
            		alt44=1;
            	}
                break;
            case PLUS_EQUAL:
            	{
            		alt44=2;
            	}
                break;
            case MINUS_EQUAL:
            	{
            		alt44=3;
            	}
                break;
            case TIMES_EQUAL:
            	{
            		alt44=4;
            	}
                break;
            case DIV_EQUAL:
            	{
            		alt44=5;
            	}
                break;
            case MOD_EQUAL:
            	{
            		alt44=6;
            	}
                break;
            case HAT_EQUAL:
            	{
            		alt44=7;
            	}
                break;
            case PIPE_EQUAL:
            	{
            		alt44=8;
            	}
                break;
            case AMP_EQUAL:
            	{
            		alt44=9;
            	}
                break;
            case COLON_EQUAL:
            	{
            		alt44=10;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return kind;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 44;
                EXCEPTION->state        = 0;


                goto ruleassignmentOpEx;

            }

            switch (alt44)
            {
        	case 1:
        	    // Cortolang.g:958:5: EQUAL
        	    {
        	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_assignmentOp3925);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:961:5: PLUS_EQUAL
        	    {
        	         MATCHT(PLUS_EQUAL, &FOLLOW_PLUS_EQUAL_in_assignmentOp3943);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_ADD; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:964:5: MINUS_EQUAL
        	    {
        	         MATCHT(MINUS_EQUAL, &FOLLOW_MINUS_EQUAL_in_assignmentOp3961);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_SUB; 
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:967:5: TIMES_EQUAL
        	    {
        	         MATCHT(TIMES_EQUAL, &FOLLOW_TIMES_EQUAL_in_assignmentOp3979);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_MUL; 
        	        }


        	    }
        	    break;
        	case 5:
        	    // Cortolang.g:970:5: DIV_EQUAL
        	    {
        	         MATCHT(DIV_EQUAL, &FOLLOW_DIV_EQUAL_in_assignmentOp3997);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_DIV; 
        	        }


        	    }
        	    break;
        	case 6:
        	    // Cortolang.g:973:5: MOD_EQUAL
        	    {
        	         MATCHT(MOD_EQUAL, &FOLLOW_MOD_EQUAL_in_assignmentOp4015);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_MOD; 
        	        }


        	    }
        	    break;
        	case 7:
        	    // Cortolang.g:976:5: HAT_EQUAL
        	    {
        	         MATCHT(HAT_EQUAL, &FOLLOW_HAT_EQUAL_in_assignmentOp4033);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_XOR; 
        	        }


        	    }
        	    break;
        	case 8:
        	    // Cortolang.g:979:5: PIPE_EQUAL
        	    {
        	         MATCHT(PIPE_EQUAL, &FOLLOW_PIPE_EQUAL_in_assignmentOp4051);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_OR; 
        	        }


        	    }
        	    break;
        	case 9:
        	    // Cortolang.g:982:5: AMP_EQUAL
        	    {
        	         MATCHT(AMP_EQUAL, &FOLLOW_AMP_EQUAL_in_assignmentOp4069);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_AND; 
        	        }


        	    }
        	    break;
        	case 10:
        	    // Cortolang.g:985:5: COLON_EQUAL
        	    {
        	         MATCHT(COLON_EQUAL, &FOLLOW_COLON_EQUAL_in_assignmentOp4087);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignmentOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ASSIGN_UPDATE; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleassignmentOpEx; /* Prevent compiler warnings */
    ruleassignmentOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return kind;
}
/* $ANTLR end assignmentOp */

/**
 * $ANTLR start eqOp
 * Cortolang.g:990:1: eqOp returns [ corto_operatorKind ___ kind ] : ( EQUALS | NOT_EQUALS );
 */
static corto_operatorKind ___
eqOp(pCortolangParser ctx)
{
    corto_operatorKind ___ kind;


    /* Initialize rule variables
     */


        kind = (corto_operatorKind)0;

    {
        {
            //  Cortolang.g:996:5: ( EQUALS | NOT_EQUALS )

            ANTLR3_UINT32 alt45;

            alt45=2;

            switch ( LA(1) )
            {
            case EQUALS:
            	{
            		alt45=1;
            	}
                break;
            case NOT_EQUALS:
            	{
            		alt45=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return kind;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 45;
                EXCEPTION->state        = 0;


                goto ruleeqOpEx;

            }

            switch (alt45)
            {
        	case 1:
        	    // Cortolang.g:997:5: EQUALS
        	    {
        	         MATCHT(EQUALS, &FOLLOW_EQUALS_in_eqOp4124);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleeqOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_COND_EQ; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1000:5: NOT_EQUALS
        	    {
        	         MATCHT(NOT_EQUALS, &FOLLOW_NOT_EQUALS_in_eqOp4142);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleeqOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_COND_NEQ; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleeqOpEx; /* Prevent compiler warnings */
    ruleeqOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return kind;
}
/* $ANTLR end eqOp */

/**
 * $ANTLR start comparisonOp
 * Cortolang.g:1005:1: comparisonOp returns [ corto_operatorKind ___ kind ] : ( GREATER_THAN | LESS_THAN | GREATER_THAN_EQUAL | LESS_THAN_EQUAL );
 */
static corto_operatorKind ___
comparisonOp(pCortolangParser ctx)
{
    corto_operatorKind ___ kind;


    /* Initialize rule variables
     */


        kind = (corto_operatorKind)0;

    {
        {
            //  Cortolang.g:1011:5: ( GREATER_THAN | LESS_THAN | GREATER_THAN_EQUAL | LESS_THAN_EQUAL )

            ANTLR3_UINT32 alt46;

            alt46=4;

            switch ( LA(1) )
            {
            case GREATER_THAN:
            	{
            		alt46=1;
            	}
                break;
            case LESS_THAN:
            	{
            		alt46=2;
            	}
                break;
            case GREATER_THAN_EQUAL:
            	{
            		alt46=3;
            	}
                break;
            case LESS_THAN_EQUAL:
            	{
            		alt46=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return kind;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 46;
                EXCEPTION->state        = 0;


                goto rulecomparisonOpEx;

            }

            switch (alt46)
            {
        	case 1:
        	    // Cortolang.g:1012:5: GREATER_THAN
        	    {
        	         MATCHT(GREATER_THAN, &FOLLOW_GREATER_THAN_in_comparisonOp4179);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomparisonOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_COND_GT; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1015:5: LESS_THAN
        	    {
        	         MATCHT(LESS_THAN, &FOLLOW_LESS_THAN_in_comparisonOp4197);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomparisonOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_COND_LT; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:1018:5: GREATER_THAN_EQUAL
        	    {
        	         MATCHT(GREATER_THAN_EQUAL, &FOLLOW_GREATER_THAN_EQUAL_in_comparisonOp4215);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomparisonOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_COND_GTEQ; 
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:1021:5: LESS_THAN_EQUAL
        	    {
        	         MATCHT(LESS_THAN_EQUAL, &FOLLOW_LESS_THAN_EQUAL_in_comparisonOp4233);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomparisonOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_COND_LTEQ; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecomparisonOpEx; /* Prevent compiler warnings */
    rulecomparisonOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return kind;
}
/* $ANTLR end comparisonOp */

/**
 * $ANTLR start shiftOp
 * Cortolang.g:1026:1: shiftOp returns [ corto_operatorKind ___ kind ] : ( LSHIFT | RSHIFT );
 */
static corto_operatorKind ___
shiftOp(pCortolangParser ctx)
{
    corto_operatorKind ___ kind;


    /* Initialize rule variables
     */


        kind = (corto_operatorKind)0;

    {
        {
            //  Cortolang.g:1032:5: ( LSHIFT | RSHIFT )

            ANTLR3_UINT32 alt47;

            alt47=2;

            switch ( LA(1) )
            {
            case LSHIFT:
            	{
            		alt47=1;
            	}
                break;
            case RSHIFT:
            	{
            		alt47=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return kind;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 47;
                EXCEPTION->state        = 0;


                goto ruleshiftOpEx;

            }

            switch (alt47)
            {
        	case 1:
        	    // Cortolang.g:1033:5: LSHIFT
        	    {
        	         MATCHT(LSHIFT, &FOLLOW_LSHIFT_in_shiftOp4270);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshiftOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_SHIFT_LEFT; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1036:5: RSHIFT
        	    {
        	         MATCHT(RSHIFT, &FOLLOW_RSHIFT_in_shiftOp4288);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshiftOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_SHIFT_RIGHT; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleshiftOpEx; /* Prevent compiler warnings */
    ruleshiftOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return kind;
}
/* $ANTLR end shiftOp */

/**
 * $ANTLR start addOp
 * Cortolang.g:1041:1: addOp returns [ corto_operatorKind ___ kind ] : ( PLUS | MINUS );
 */
static corto_operatorKind ___
addOp(pCortolangParser ctx)
{
    corto_operatorKind ___ kind;


    /* Initialize rule variables
     */


        kind = (corto_operatorKind)0;

    {
        {
            //  Cortolang.g:1047:5: ( PLUS | MINUS )

            ANTLR3_UINT32 alt48;

            alt48=2;

            switch ( LA(1) )
            {
            case PLUS:
            	{
            		alt48=1;
            	}
                break;
            case MINUS:
            	{
            		alt48=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return kind;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 48;
                EXCEPTION->state        = 0;


                goto ruleaddOpEx;

            }

            switch (alt48)
            {
        	case 1:
        	    // Cortolang.g:1048:5: PLUS
        	    {
        	         MATCHT(PLUS, &FOLLOW_PLUS_in_addOp4325);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleaddOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_ADD; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1051:5: MINUS
        	    {
        	         MATCHT(MINUS, &FOLLOW_MINUS_in_addOp4343);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleaddOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_SUB; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleaddOpEx; /* Prevent compiler warnings */
    ruleaddOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return kind;
}
/* $ANTLR end addOp */

/**
 * $ANTLR start multOp
 * Cortolang.g:1056:1: multOp returns [ corto_operatorKind ___ kind ] : ( ASTERISK | SLASH );
 */
static corto_operatorKind ___
multOp(pCortolangParser ctx)
{
    corto_operatorKind ___ kind;


    /* Initialize rule variables
     */


        kind = (corto_operatorKind)0;

    {
        {
            //  Cortolang.g:1062:5: ( ASTERISK | SLASH )

            ANTLR3_UINT32 alt49;

            alt49=2;

            switch ( LA(1) )
            {
            case ASTERISK:
            	{
            		alt49=1;
            	}
                break;
            case SLASH:
            	{
            		alt49=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return kind;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 49;
                EXCEPTION->state        = 0;


                goto rulemultOpEx;

            }

            switch (alt49)
            {
        	case 1:
        	    // Cortolang.g:1063:5: ASTERISK
        	    {
        	         MATCHT(ASTERISK, &FOLLOW_ASTERISK_in_multOp4380);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_MUL; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1066:5: SLASH
        	    {
        	         MATCHT(SLASH, &FOLLOW_SLASH_in_multOp4398);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_DIV; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemultOpEx; /* Prevent compiler warnings */
    rulemultOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return kind;
}
/* $ANTLR end multOp */

/**
 * $ANTLR start unaryOp
 * Cortolang.g:1071:1: unaryOp returns [ corto_operatorKind ___ kind ] : ( TILDE | MINUS | EMARK | KW_NOT );
 */
static corto_operatorKind ___
unaryOp(pCortolangParser ctx)
{
    corto_operatorKind ___ kind;


    /* Initialize rule variables
     */


        kind = (corto_operatorKind)0;

    {
        {
            //  Cortolang.g:1077:5: ( TILDE | MINUS | EMARK | KW_NOT )

            ANTLR3_UINT32 alt50;

            alt50=4;

            switch ( LA(1) )
            {
            case TILDE:
            	{
            		alt50=1;
            	}
                break;
            case MINUS:
            	{
            		alt50=2;
            	}
                break;
            case EMARK:
            	{
            		alt50=3;
            	}
                break;
            case KW_NOT:
            	{
            		alt50=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return kind;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 50;
                EXCEPTION->state        = 0;


                goto ruleunaryOpEx;

            }

            switch (alt50)
            {
        	case 1:
        	    // Cortolang.g:1078:5: TILDE
        	    {
        	         MATCHT(TILDE, &FOLLOW_TILDE_in_unaryOp4435);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_NOT; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1081:5: MINUS
        	    {
        	         MATCHT(MINUS, &FOLLOW_MINUS_in_unaryOp4453);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_SUB; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:1089:5: EMARK
        	    {
        	         MATCHT(EMARK, &FOLLOW_EMARK_in_unaryOp4496);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_COND_NOT; 
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:1092:5: KW_NOT
        	    {
        	         MATCHT(KW_NOT, &FOLLOW_KW_NOT_in_unaryOp4514);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return kind;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             kind = CORTO_COND_NOT; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleunaryOpEx; /* Prevent compiler warnings */
    ruleunaryOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return kind;
}
/* $ANTLR end unaryOp */

/**
 * $ANTLR start postfixOperation
 * Cortolang.g:1096:1: postfixOperation[ parser_ExpressionNode ___ _node ] returns [ parser_ExpressionNode ___ node ] : ( functionCall[ _node ] | memberAccess[ _node ] | elementAccess[ _node ] );
 */
static parser_ExpressionNode ___
postfixOperation(pCortolangParser ctx, parser_ExpressionNode ___ _node)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ functionCall15;
    #undef	RETURN_TYPE_functionCall15
    #define	RETURN_TYPE_functionCall15 parser_ExpressionNode ___

    parser_ExpressionNode ___ memberAccess16;
    #undef	RETURN_TYPE_memberAccess16
    #define	RETURN_TYPE_memberAccess16 parser_ExpressionNode ___

    parser_ExpressionNode ___ elementAccess17;
    #undef	RETURN_TYPE_elementAccess17
    #define	RETURN_TYPE_elementAccess17 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        {
            //  Cortolang.g:1102:5: ( functionCall[ _node ] | memberAccess[ _node ] | elementAccess[ _node ] )

            ANTLR3_UINT32 alt51;

            alt51=3;

            switch ( LA(1) )
            {
            case LPAREN:
            	{
            		alt51=1;
            	}
                break;
            case DOT:
            	{
            		alt51=2;
            	}
                break;
            case LBRACK:
            	{
            		alt51=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return node;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 51;
                EXCEPTION->state        = 0;


                goto rulepostfixOperationEx;

            }

            switch (alt51)
            {
        	case 1:
        	    // Cortolang.g:1103:5: functionCall[ _node ]
        	    {
        	        FOLLOWPUSH(FOLLOW_functionCall_in_postfixOperation4552);
        	        functionCall15=functionCall(ctx, _node);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostfixOperationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = functionCall15
        	            ;
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1108:5: memberAccess[ _node ]
        	    {
        	        FOLLOWPUSH(FOLLOW_memberAccess_in_postfixOperation4572);
        	        memberAccess16=memberAccess(ctx, _node);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostfixOperationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = memberAccess16
        	            ;
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:1113:5: elementAccess[ _node ]
        	    {
        	        FOLLOWPUSH(FOLLOW_elementAccess_in_postfixOperation4592);
        	        elementAccess17=elementAccess(ctx, _node);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostfixOperationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = elementAccess17
        	            ;
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulepostfixOperationEx; /* Prevent compiler warnings */
    rulepostfixOperationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end postfixOperation */

/**
 * $ANTLR start functionCall
 * Cortolang.g:1120:1: functionCall[ parser_ExpressionNode ___ _node ] returns [ parser_ExpressionNode ___ node ] : LPAREN e= fullCommaExpression RPAREN ;
 */
static parser_ExpressionNode ___
functionCall(pCortolangParser ctx, parser_ExpressionNode ___ _node)
{
    parser_ExpressionNode ___ node;


    parser_FullCommaExpressionNode ___ e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e parser_FullCommaExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:1126:5: ( LPAREN e= fullCommaExpression RPAREN )
        // Cortolang.g:1127:5: LPAREN e= fullCommaExpression RPAREN
        {
             MATCHT(LPAREN, &FOLLOW_LPAREN_in_functionCall4633);
            if  (HASEXCEPTION())
            {
                goto rulefunctionCallEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            FOLLOWPUSH(FOLLOW_fullCommaExpression_in_functionCall4641);
            e=fullCommaExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionCallEx;
            }
            if (HASFAILED())
            {
                return node;
            }


             MATCHT(RPAREN, &FOLLOW_RPAREN_in_functionCall4647);
            if  (HASEXCEPTION())
            {
                goto rulefunctionCallEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            if ( BACKTRACKING==0 )
            {

                        node = parser_pw_createCallExpression(_node, e
                );
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionCallEx; /* Prevent compiler warnings */
    rulefunctionCallEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end functionCall */

/**
 * $ANTLR start memberAccess
 * Cortolang.g:1136:1: memberAccess[ parser_ExpressionNode ___ _node ] returns [ parser_ExpressionNode ___ node ] : DOT VALID_NAME ;
 */
static parser_ExpressionNode ___
memberAccess(pCortolangParser ctx, parser_ExpressionNode ___ _node)
{
    parser_ExpressionNode ___ node;


    pANTLR3_COMMON_TOKEN    VALID_NAME18;

    /* Initialize rule variables
     */


        node = NULL;

    VALID_NAME18       = NULL;

    {
        // Cortolang.g:1142:5: ( DOT VALID_NAME )
        // Cortolang.g:1143:5: DOT VALID_NAME
        {
             MATCHT(DOT, &FOLLOW_DOT_in_memberAccess4686);
            if  (HASEXCEPTION())
            {
                goto rulememberAccessEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            VALID_NAME18 = (pANTLR3_COMMON_TOKEN) MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_memberAccess4688);
            if  (HASEXCEPTION())
            {
                goto rulememberAccessEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            if ( BACKTRACKING==0 )
            {

                        node = parser_pw_createMemberExpression(_node, CHARS((VALID_NAME18->getText(VALID_NAME18))));
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulememberAccessEx; /* Prevent compiler warnings */
    rulememberAccessEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end memberAccess */

/**
 * $ANTLR start elementAccess
 * Cortolang.g:1150:1: elementAccess[ parser_ExpressionNode ___ _node ] returns [ parser_ExpressionNode ___ node ] : LBRACK fullCommaExpression RBRACK ;
 */
static parser_ExpressionNode ___
elementAccess(pCortolangParser ctx, parser_ExpressionNode ___ _node)
{
    parser_ExpressionNode ___ node;


    parser_FullCommaExpressionNode ___ fullCommaExpression19;
    #undef	RETURN_TYPE_fullCommaExpression19
    #define	RETURN_TYPE_fullCommaExpression19 parser_FullCommaExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:1156:5: ( LBRACK fullCommaExpression RBRACK )
        // Cortolang.g:1157:5: LBRACK fullCommaExpression RBRACK
        {
             MATCHT(LBRACK, &FOLLOW_LBRACK_in_elementAccess4728);
            if  (HASEXCEPTION())
            {
                goto ruleelementAccessEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            FOLLOWPUSH(FOLLOW_fullCommaExpression_in_elementAccess4730);
            fullCommaExpression19=fullCommaExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleelementAccessEx;
            }
            if (HASFAILED())
            {
                return node;
            }


             MATCHT(RBRACK, &FOLLOW_RBRACK_in_elementAccess4732);
            if  (HASEXCEPTION())
            {
                goto ruleelementAccessEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            if ( BACKTRACKING==0 )
            {

                        node = parser_pw_createElementExpression(_node, fullCommaExpression19
                );
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleelementAccessEx; /* Prevent compiler warnings */
    ruleelementAccessEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end elementAccess */

/**
 * $ANTLR start constant
 * Cortolang.g:1169:1: constant : ( VALID_NAME | GID | literal );
 */
static void
constant(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:1170:5: ( VALID_NAME | GID | literal )

            ANTLR3_UINT32 alt52;

            alt52=3;

            switch ( LA(1) )
            {
            case VALID_NAME:
            	{
            		alt52=1;
            	}
                break;
            case GID:
            	{
            		alt52=2;
            	}
                break;
            case CHARACTER:
            case INTEGER:
            case KW_FALSE:
            case KW_TRUE:
            case STRING:
            	{
            		alt52=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 52;
                EXCEPTION->state        = 0;


                goto ruleconstantEx;

            }

            switch (alt52)
            {
        	case 1:
        	    // Cortolang.g:1171:5: VALID_NAME
        	    {
        	         MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_constant4765);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1173:5: GID
        	    {
        	         MATCHT(GID, &FOLLOW_GID_in_constant4777);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:1175:5: literal
        	    {
        	        FOLLOWPUSH(FOLLOW_literal_in_constant4789);
        	        literal(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end constant */

/**
 * $ANTLR start identifier
 * Cortolang.g:1178:1: identifier : ( VALID_NAME | GID );
 */
static CortolangParser_identifier_return
identifier(pCortolangParser ctx)
{
    CortolangParser_identifier_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // Cortolang.g:1179:5: ( VALID_NAME | GID )
        // Cortolang.g:
        {
            if ( LA(1) == GID || LA(1) == VALID_NAME )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleidentifierEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end identifier */

/**
 * $ANTLR start typeLabel
 * Cortolang.g:1186:1: typeLabel returns [ parser_BaseTypeExpressionNode ___ node ] : ( identifier ) ( LBRACE fullCommaExpression RBRACE )* ;
 */
static parser_BaseTypeExpressionNode ___
typeLabel(pCortolangParser ctx)
{
    parser_BaseTypeExpressionNode ___ node;


    CortolangParser_identifier_return identifier20;
    #undef	RETURN_TYPE_identifier20
    #define	RETURN_TYPE_identifier20 CortolangParser_identifier_return

    parser_FullCommaExpressionNode ___ fullCommaExpression21;
    #undef	RETURN_TYPE_fullCommaExpression21
    #define	RETURN_TYPE_fullCommaExpression21 parser_FullCommaExpressionNode ___

    /* Initialize rule variables
     */


        parser_SimpleTypeExpressionNode ste = NULL;
        parser_InitializerTypeExpressionNode ite = NULL;
        node = NULL;

    {
        // Cortolang.g:1194:5: ( ( identifier ) ( LBRACE fullCommaExpression RBRACE )* )
        // Cortolang.g:1195:5: ( identifier ) ( LBRACE fullCommaExpression RBRACE )*
        {
            // Cortolang.g:1195:5: ( identifier )
            // Cortolang.g:1196:9: identifier
            {
                FOLLOWPUSH(FOLLOW_identifier_in_typeLabel4863);
                identifier20=identifier(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruletypeLabelEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {


                                ste = parser_SimpleTypeExpressionNodeCreate(0, 0, CHARS((STRSTREAM->toStringTT(STRSTREAM, identifier20.start, identifier20.stop))
                    ));
                                node = parser_BaseTypeExpressionNode(ste);
                            
                }


            }


            // Cortolang.g:1203:5: ( LBRACE fullCommaExpression RBRACE )*

            for (;;)
            {
                int alt53=2;
                switch ( LA(1) )
                {
                case LBRACE:
                	{
                		alt53=1;
                	}
                    break;

                }

                switch (alt53)
                {
            	case 1:
            	    // Cortolang.g:1204:9: LBRACE fullCommaExpression RBRACE
            	    {
            	         MATCHT(LBRACE, &FOLLOW_LBRACE_in_typeLabel4895);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeLabelEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_fullCommaExpression_in_typeLabel4905);
            	        fullCommaExpression21=fullCommaExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeLabelEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	         MATCHT(RBRACE, &FOLLOW_RBRACE_in_typeLabel4915);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeLabelEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        ite = parser_InitializerTypeExpressionNodeCreate(
            	                            0, 0, node, fullCommaExpression21

            	                        );
            	                        node = parser_BaseTypeExpressionNode(ite);
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop53;	/* break out of the loop */
            	    break;
                }
            }
            loop53: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletypeLabelEx; /* Prevent compiler warnings */
    ruletypeLabelEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end typeLabel */

/**
 * $ANTLR start literal
 * Cortolang.g:1217:1: literal returns [ parser_LiteralNode ___ node ] : ( booleanLiteral | CHARACTER | integerLiteral | STRING );
 */
static parser_LiteralNode ___
literal(pCortolangParser ctx)
{
    parser_LiteralNode ___ node;


    parser_LiteralNode ___ booleanLiteral22;
    #undef	RETURN_TYPE_booleanLiteral22
    #define	RETURN_TYPE_booleanLiteral22 parser_LiteralNode ___

    parser_LiteralNode ___ integerLiteral23;
    #undef	RETURN_TYPE_integerLiteral23
    #define	RETURN_TYPE_integerLiteral23 parser_LiteralNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        {
            //  Cortolang.g:1223:5: ( booleanLiteral | CHARACTER | integerLiteral | STRING )

            ANTLR3_UINT32 alt54;

            alt54=4;

            switch ( LA(1) )
            {
            case KW_FALSE:
            case KW_TRUE:
            	{
            		alt54=1;
            	}
                break;
            case CHARACTER:
            	{
            		alt54=2;
            	}
                break;
            case INTEGER:
            	{
            		alt54=3;
            	}
                break;
            case STRING:
            	{
            		alt54=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return node;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 54;
                EXCEPTION->state        = 0;


                goto ruleliteralEx;

            }

            switch (alt54)
            {
        	case 1:
        	    // Cortolang.g:1224:5: booleanLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_booleanLiteral_in_literal4963);
        	        booleanLiteral22=booleanLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             node = booleanLiteral22
        	            ; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:1227:5: CHARACTER
        	    {
        	         MATCHT(CHARACTER, &FOLLOW_CHARACTER_in_literal4981);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:1229:5: integerLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_integerLiteral_in_literal4993);
        	        integerLiteral23=integerLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             node = integerLiteral23
        	            ; 
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:1232:5: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_literal5011);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end literal */

/**
 * $ANTLR start booleanLiteral
 * Cortolang.g:1236:1: booleanLiteral returns [ parser_LiteralNode ___ node ] : ( KW_TRUE | KW_FALSE ) ;
 */
static parser_LiteralNode ___
booleanLiteral(pCortolangParser ctx)
{
    parser_LiteralNode ___ node;


    /* Initialize rule variables
     */


        node = NULL;
        parser_BooleanLiteralNode _node = parser_BooleanLiteralNodeCreate(0, 0, TRUE);

    {
        // Cortolang.g:1243:5: ( ( KW_TRUE | KW_FALSE ) )
        // Cortolang.g:1244:5: ( KW_TRUE | KW_FALSE )
        {
            // Cortolang.g:1244:5: ( KW_TRUE | KW_FALSE )
            {
                int alt55=2;
                switch ( LA(1) )
                {
                case KW_TRUE:
                	{
                		alt55=1;
                	}
                    break;
                case KW_FALSE:
                	{
                		alt55=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return node;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 55;
                    EXCEPTION->state        = 0;


                    goto rulebooleanLiteralEx;

                }

                switch (alt55)
                {
            	case 1:
            	    // Cortolang.g:1245:9: KW_TRUE
            	    {
            	         MATCHT(KW_TRUE, &FOLLOW_KW_TRUE_in_booleanLiteral5052);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebooleanLiteralEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             _node = parser_BooleanLiteralNodeCreate(0, 0, TRUE); 
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:1248:9: KW_FALSE
            	    {
            	         MATCHT(KW_FALSE, &FOLLOW_KW_FALSE_in_booleanLiteral5082);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebooleanLiteralEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	             _node = parser_BooleanLiteralNodeCreate(0, 0, FALSE); 
            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                        node = parser_LiteralNode(_node);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebooleanLiteralEx; /* Prevent compiler warnings */
    rulebooleanLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end booleanLiteral */

/**
 * $ANTLR start integerLiteral
 * Cortolang.g:1257:1: integerLiteral returns [ parser_LiteralNode ___ node ] : INTEGER ;
 */
static parser_LiteralNode ___
integerLiteral(pCortolangParser ctx)
{
    parser_LiteralNode ___ node;


    pANTLR3_COMMON_TOKEN    INTEGER24;

    /* Initialize rule variables
     */


        node = NULL;

    INTEGER24       = NULL;

    {
        // Cortolang.g:1263:5: ( INTEGER )
        // Cortolang.g:1264:5: INTEGER
        {
            INTEGER24 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_integerLiteral5135);
            if  (HASEXCEPTION())
            {
                goto ruleintegerLiteralEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            if ( BACKTRACKING==0 )
            {

                        node = parser_pw_createIntegerLiteralNode(CHARS((INTEGER24->getText(INTEGER24))));
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleintegerLiteralEx; /* Prevent compiler warnings */
    ruleintegerLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end integerLiteral */

// $ANTLR start synpred1_Cortolang
static void synpred1_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:76:5: ( declarativeStatement )
    // Cortolang.g:76:6: declarativeStatement
    {
        FOLLOWPUSH(FOLLOW_declarativeStatement_in_synpred1_Cortolang186);
        declarativeStatement(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_CortolangEx; /* Prevent compiler warnings */
rulesynpred1_CortolangEx: ;

}
// $ANTLR end synpred1_Cortolang

// $ANTLR start synpred2_Cortolang
static void synpred2_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:101:5: ( functionDeclaration )
    // Cortolang.g:101:6: functionDeclaration
    {
        FOLLOWPUSH(FOLLOW_functionDeclaration_in_synpred2_Cortolang283);
        functionDeclaration(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_CortolangEx; /* Prevent compiler warnings */
rulesynpred2_CortolangEx: ;

}
// $ANTLR end synpred2_Cortolang

// $ANTLR start synpred3_Cortolang
static void synpred3_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:107:5: ( declarationExt )
    // Cortolang.g:107:6: declarationExt
    {
        FOLLOWPUSH(FOLLOW_declarationExt_in_synpred3_Cortolang311);
        declarationExt(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred3_CortolangEx; /* Prevent compiler warnings */
rulesynpred3_CortolangEx: ;

}
// $ANTLR end synpred3_Cortolang

// $ANTLR start synpred4_Cortolang
static void synpred4_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:208:9: ( typeLabel declarationNameList )
    // Cortolang.g:208:10: typeLabel declarationNameList
    {
        FOLLOWPUSH(FOLLOW_typeLabel_in_synpred4_Cortolang664);
        typeLabel(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        FOLLOWPUSH(FOLLOW_declarationNameList_in_synpred4_Cortolang666);
        declarationNameList(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred4_CortolangEx; /* Prevent compiler warnings */
rulesynpred4_CortolangEx: ;

}
// $ANTLR end synpred4_Cortolang

// $ANTLR start synpred5_Cortolang
static void synpred5_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:436:9: ( KW_ELSE )
    // Cortolang.g:436:11: KW_ELSE
    {
         MATCHT(KW_ELSE, &FOLLOW_KW_ELSE_in_synpred5_Cortolang1656);
        if  (HASEXCEPTION())
        {
            goto rulesynpred5_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred5_CortolangEx; /* Prevent compiler warnings */
rulesynpred5_CortolangEx: ;

}
// $ANTLR end synpred5_Cortolang

// $ANTLR start synpred6_Cortolang
static void synpred6_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:815:9: ( addOp multExpression )
    // Cortolang.g:815:10: addOp multExpression
    {
        FOLLOWPUSH(FOLLOW_addOp_in_synpred6_Cortolang3356);
        addOp(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred6_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        FOLLOWPUSH(FOLLOW_multExpression_in_synpred6_Cortolang3358);
        multExpression(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred6_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred6_CortolangEx; /* Prevent compiler warnings */
rulesynpred6_CortolangEx: ;

}
// $ANTLR end synpred6_Cortolang
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred5_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred5_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred4_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred4_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred3_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred3_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred6_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred6_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred2_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred2_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred1_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
