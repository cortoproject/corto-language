/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : Cortolang.g
 *     -                            On : 2016-05-31 20:36:38
 *     -                for the parser : CortolangParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "CortolangParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pCortolangParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pCortolangParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pCortolangParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pCortolangParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   CortolangParserTokenNames[73+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AMPERSAND",
        (pANTLR3_UINT8) "ASTERISK",
        (pANTLR3_UINT8) "BITAND_EQUALS",
        (pANTLR3_UINT8) "BITOR_EQUALS",
        (pANTLR3_UINT8) "BITXOR_EQUALS",
        (pANTLR3_UINT8) "CHARACTER",
        (pANTLR3_UINT8) "CIRCUMFLEX",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "DEDENT",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DIV_EQUAL",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "DOUBLE_COLON",
        (pANTLR3_UINT8) "EMARK",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "EQUALS",
        (pANTLR3_UINT8) "ESC",
        (pANTLR3_UINT8) "GID",
        (pANTLR3_UINT8) "GREATER_THAN",
        (pANTLR3_UINT8) "GREATER_THAN_EQUAL",
        (pANTLR3_UINT8) "IMPLICIT_LINE_WHITESPACE",
        (pANTLR3_UINT8) "INDENT",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "KW_AND",
        (pANTLR3_UINT8) "KW_BREAK",
        (pANTLR3_UINT8) "KW_CONTINUE",
        (pANTLR3_UINT8) "KW_DECLARE",
        (pANTLR3_UINT8) "KW_DEFINE",
        (pANTLR3_UINT8) "KW_DESTRUCT",
        (pANTLR3_UINT8) "KW_ELSE",
        (pANTLR3_UINT8) "KW_FALSE",
        (pANTLR3_UINT8) "KW_FOR",
        (pANTLR3_UINT8) "KW_IF",
        (pANTLR3_UINT8) "KW_ON",
        (pANTLR3_UINT8) "KW_OR",
        (pANTLR3_UINT8) "KW_SCOPE",
        (pANTLR3_UINT8) "KW_SELF",
        (pANTLR3_UINT8) "KW_SYNCHRONIZED",
        (pANTLR3_UINT8) "KW_TREE",
        (pANTLR3_UINT8) "KW_TRUE",
        (pANTLR3_UINT8) "KW_UPDATE",
        (pANTLR3_UINT8) "KW_WAIT",
        (pANTLR3_UINT8) "KW_WHILE",
        (pANTLR3_UINT8) "LBRACE",
        (pANTLR3_UINT8) "LBRACK",
        (pANTLR3_UINT8) "LEADING_WHITESPACE",
        (pANTLR3_UINT8) "LESS_THAN",
        (pANTLR3_UINT8) "LESS_THAN_EQUAL",
        (pANTLR3_UINT8) "LETTER_UNDERSCORE",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "LSHIFT",
        (pANTLR3_UINT8) "LSHIFT_EQUALS",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "MINUS_EQUAL",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "NOT_EQUALS",
        (pANTLR3_UINT8) "PIPE",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "PLUS_EQUAL",
        (pANTLR3_UINT8) "QMARK",
        (pANTLR3_UINT8) "RBRACE",
        (pANTLR3_UINT8) "RBRACK",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "RSHIFT",
        (pANTLR3_UINT8) "RSHIFT_EQUALS",
        (pANTLR3_UINT8) "SLASH",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "TILDE",
        (pANTLR3_UINT8) "TIMES_EQUAL",
        (pANTLR3_UINT8) "TRIPLE_COLON",
        (pANTLR3_UINT8) "VALID_NAME",
        (pANTLR3_UINT8) "WHITESPACE"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 parser_ProgramNode ___
	program    (pCortolangParser ctx);
static 
 parser_StatementNode ___
	statement    (pCortolangParser ctx);
static 
 void
	declarativeStatement    (pCortolangParser ctx);
static 
 parser_StatementNode ___
	simpleStatement    (pCortolangParser ctx);
static 
 void
	compositeStatement    (pCortolangParser ctx);
static 
 void
	block    (pCortolangParser ctx);
static 
 void
	declarationExt    (pCortolangParser ctx);
static 
 void
	declarationNameList    (pCortolangParser ctx);
static 
 void
	declarationName    (pCortolangParser ctx);
static 
 void
	initializer    (pCortolangParser ctx);
static 
 void
	scopeOp    (pCortolangParser ctx);
static 
 void
	scope_    (pCortolangParser ctx);
static 
 void
	functionDeclaration    (pCortolangParser ctx);
static 
 void
	functionArguments    (pCortolangParser ctx);
static 
 void
	functionArgument    (pCortolangParser ctx);
static 
 void
	ifStatement    (pCortolangParser ctx);
static 
 void
	elseStatement    (pCortolangParser ctx);
static 
 void
	whileStatement    (pCortolangParser ctx);
static 
 void
	breakStatement    (pCortolangParser ctx);
static 
 void
	continueStatement    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	expression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	assignmentExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	simpleCommaExpression    (pCortolangParser ctx);
static 
 void
	fullCommaExpression    (pCortolangParser ctx);
static 
 void
	commaExpressionElem    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	conditionalExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	logicOrExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	logicAndExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	equalityExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	comparisonExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	bitOrExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	bitXorExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	bitAndExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	shiftExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	addExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	multExpression    (pCortolangParser ctx);
static 
 parser_ExpressionNode ___
	unaryExpression    (pCortolangParser ctx);
static 
 void
	postfixExpression    (pCortolangParser ctx);
static 
 void
	atomExpression    (pCortolangParser ctx);
static 
 void
	anonymousObject    (pCortolangParser ctx);
static 
 void
	observerStatement    (pCortolangParser ctx);
static 
 void
	eventMask    (pCortolangParser ctx);
static 
 void
	eventFlag    (pCortolangParser ctx);
static 
 void
	eventBaseFlag    (pCortolangParser ctx);
static 
 void
	eventScopeFlag    (pCortolangParser ctx);
static 
 void
	assignmentOp    (pCortolangParser ctx);
static 
 void
	eqOp    (pCortolangParser ctx);
static 
 void
	comparisonOp    (pCortolangParser ctx);
static 
 void
	shiftOp    (pCortolangParser ctx);
static 
 void
	addOp    (pCortolangParser ctx);
static 
 void
	multOp    (pCortolangParser ctx);
static 
 void
	unaryOp    (pCortolangParser ctx);
static 
 void
	postfixOperation    (pCortolangParser ctx);
static 
 void
	functionCall    (pCortolangParser ctx);
static 
 void
	memberAccess    (pCortolangParser ctx);
static 
 void
	elementAccess    (pCortolangParser ctx);
static 
 void
	postScopeOperator    (pCortolangParser ctx);
static 
 void
	preScopeOperator    (pCortolangParser ctx);
static 
 void
	constant    (pCortolangParser ctx);
static 
 void
	identifier    (pCortolangParser ctx);
static 
 void
	typeLabel    (pCortolangParser ctx);
static 
 void
	literal    (pCortolangParser ctx);
static 
 void
	booleanLiteral    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred1_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred2_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred3_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred4_Cortolang    (pCortolangParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred5_Cortolang    (pCortolangParser ctx);
static void	CortolangParserFree(pCortolangParser ctx);
static void     CortolangParserReset (pCortolangParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Cortolang.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new CortolangParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCortolangParser
CortolangParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return CortolangParserNewSSD(instream, NULL);
}

/** \brief Create a new CortolangParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCortolangParser
CortolangParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pCortolangParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pCortolangParser) ANTLR3_CALLOC(1, sizeof(CortolangParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in CortolangParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our CortolangParser interface
     */
    ctx->program	= program;
    ctx->statement	= statement;
    ctx->declarativeStatement	= declarativeStatement;
    ctx->simpleStatement	= simpleStatement;
    ctx->compositeStatement	= compositeStatement;
    ctx->block	= block;
    ctx->declarationExt	= declarationExt;
    ctx->declarationNameList	= declarationNameList;
    ctx->declarationName	= declarationName;
    ctx->initializer	= initializer;
    ctx->scopeOp	= scopeOp;
    ctx->scope_	= scope_;
    ctx->functionDeclaration	= functionDeclaration;
    ctx->functionArguments	= functionArguments;
    ctx->functionArgument	= functionArgument;
    ctx->ifStatement	= ifStatement;
    ctx->elseStatement	= elseStatement;
    ctx->whileStatement	= whileStatement;
    ctx->breakStatement	= breakStatement;
    ctx->continueStatement	= continueStatement;
    ctx->expression	= expression;
    ctx->assignmentExpression	= assignmentExpression;
    ctx->simpleCommaExpression	= simpleCommaExpression;
    ctx->fullCommaExpression	= fullCommaExpression;
    ctx->commaExpressionElem	= commaExpressionElem;
    ctx->conditionalExpression	= conditionalExpression;
    ctx->logicOrExpression	= logicOrExpression;
    ctx->logicAndExpression	= logicAndExpression;
    ctx->equalityExpression	= equalityExpression;
    ctx->comparisonExpression	= comparisonExpression;
    ctx->bitOrExpression	= bitOrExpression;
    ctx->bitXorExpression	= bitXorExpression;
    ctx->bitAndExpression	= bitAndExpression;
    ctx->shiftExpression	= shiftExpression;
    ctx->addExpression	= addExpression;
    ctx->multExpression	= multExpression;
    ctx->unaryExpression	= unaryExpression;
    ctx->postfixExpression	= postfixExpression;
    ctx->atomExpression	= atomExpression;
    ctx->anonymousObject	= anonymousObject;
    ctx->observerStatement	= observerStatement;
    ctx->eventMask	= eventMask;
    ctx->eventFlag	= eventFlag;
    ctx->eventBaseFlag	= eventBaseFlag;
    ctx->eventScopeFlag	= eventScopeFlag;
    ctx->assignmentOp	= assignmentOp;
    ctx->eqOp	= eqOp;
    ctx->comparisonOp	= comparisonOp;
    ctx->shiftOp	= shiftOp;
    ctx->addOp	= addOp;
    ctx->multOp	= multOp;
    ctx->unaryOp	= unaryOp;
    ctx->postfixOperation	= postfixOperation;
    ctx->functionCall	= functionCall;
    ctx->memberAccess	= memberAccess;
    ctx->elementAccess	= elementAccess;
    ctx->postScopeOperator	= postScopeOperator;
    ctx->preScopeOperator	= preScopeOperator;
    ctx->constant	= constant;
    ctx->identifier	= identifier;
    ctx->typeLabel	= typeLabel;
    ctx->literal	= literal;
    ctx->booleanLiteral	= booleanLiteral;
    ctx->synpred1_Cortolang	= synpred1_Cortolang;
    ctx->synpred2_Cortolang	= synpred2_Cortolang;
    ctx->synpred3_Cortolang	= synpred3_Cortolang;
    ctx->synpred4_Cortolang	= synpred4_Cortolang;
    ctx->synpred5_Cortolang	= synpred5_Cortolang;
    ctx->free			= CortolangParserFree;
    ctx->reset			= CortolangParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */


    RECOGNIZER->displayRecognitionError = parser_DisplayRecognitionError;
    ctx->parser_data = NULL;
    PARSER->super = ctx;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = CortolangParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
CortolangParserReset (pCortolangParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 CortolangParserFree(pCortolangParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return CortolangParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_program135  */
static	ANTLR3_BITWORD FOLLOW_statement_in_program135_bits[]	= { ANTLR3_UINT64_LIT(0x4A41906868440202), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_program135	= { FOLLOW_statement_in_program135_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarativeStatement_in_statement192  */
static	ANTLR3_BITWORD FOLLOW_declarativeStatement_in_statement192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarativeStatement_in_statement192	= { FOLLOW_declarativeStatement_in_statement192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleStatement_in_statement204  */
static	ANTLR3_BITWORD FOLLOW_simpleStatement_in_statement204_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleStatement_in_statement204	= { FOLLOW_simpleStatement_in_statement204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_statement206  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_statement206_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_statement206	= { FOLLOW_NEWLINE_in_statement206_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compositeStatement_in_statement224  */
static	ANTLR3_BITWORD FOLLOW_compositeStatement_in_statement224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compositeStatement_in_statement224	= { FOLLOW_compositeStatement_in_statement224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_statement242  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_statement242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_statement242	= { FOLLOW_NEWLINE_in_statement242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_declarativeStatement273  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_declarativeStatement273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_declarativeStatement273	= { FOLLOW_functionDeclaration_in_declarativeStatement273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationExt_in_declarativeStatement295  */
static	ANTLR3_BITWORD FOLLOW_declarationExt_in_declarativeStatement295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationExt_in_declarativeStatement295	= { FOLLOW_declarationExt_in_declarativeStatement295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_simpleStatement327  */
static	ANTLR3_BITWORD FOLLOW_expression_in_simpleStatement327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_simpleStatement327	= { FOLLOW_expression_in_simpleStatement327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_breakStatement_in_simpleStatement345  */
static	ANTLR3_BITWORD FOLLOW_breakStatement_in_simpleStatement345_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_breakStatement_in_simpleStatement345	= { FOLLOW_breakStatement_in_simpleStatement345_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_continueStatement_in_simpleStatement357  */
static	ANTLR3_BITWORD FOLLOW_continueStatement_in_simpleStatement357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_continueStatement_in_simpleStatement357	= { FOLLOW_continueStatement_in_simpleStatement357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_compositeStatement378  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_compositeStatement378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_compositeStatement378	= { FOLLOW_ifStatement_in_compositeStatement378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_compositeStatement390  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_compositeStatement390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_compositeStatement390	= { FOLLOW_whileStatement_in_compositeStatement390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_observerStatement_in_compositeStatement402  */
static	ANTLR3_BITWORD FOLLOW_observerStatement_in_compositeStatement402_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_observerStatement_in_compositeStatement402	= { FOLLOW_observerStatement_in_compositeStatement402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_block423  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_block423_bits[]	= { ANTLR3_UINT64_LIT(0x4A4190686C440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_block423	= { FOLLOW_COLON_in_block423_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_block439  */
static	ANTLR3_BITWORD FOLLOW_statement_in_block439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_block439	= { FOLLOW_statement_in_block439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDENT_in_block459  */
static	ANTLR3_BITWORD FOLLOW_INDENT_in_block459_bits[]	= { ANTLR3_UINT64_LIT(0x4A41906868440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_INDENT_in_block459	= { FOLLOW_INDENT_in_block459_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_block461  */
static	ANTLR3_BITWORD FOLLOW_statement_in_block461_bits[]	= { ANTLR3_UINT64_LIT(0x4A41906868442200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_block461	= { FOLLOW_statement_in_block461_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEDENT_in_block464  */
static	ANTLR3_BITWORD FOLLOW_DEDENT_in_block464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DEDENT_in_block464	= { FOLLOW_DEDENT_in_block464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLabel_in_declarationExt498  */
static	ANTLR3_BITWORD FOLLOW_typeLabel_in_declarationExt498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLabel_in_declarationExt498	= { FOLLOW_typeLabel_in_declarationExt498_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationNameList_in_declarationExt500  */
static	ANTLR3_BITWORD FOLLOW_declarationNameList_in_declarationExt500_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000020800), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationNameList_in_declarationExt500	= { FOLLOW_declarationNameList_in_declarationExt500_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initializer_in_declarationExt502  */
static	ANTLR3_BITWORD FOLLOW_initializer_in_declarationExt502_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000020000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_initializer_in_declarationExt502	= { FOLLOW_initializer_in_declarationExt502_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_declarationExt506  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_declarationExt506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_declarationExt506	= { FOLLOW_NEWLINE_in_declarationExt506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_scope__in_declarationExt510  */
static	ANTLR3_BITWORD FOLLOW_scope__in_declarationExt510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_scope__in_declarationExt510	= { FOLLOW_scope__in_declarationExt510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationName_in_declarationNameList532  */
static	ANTLR3_BITWORD FOLLOW_declarationName_in_declarationNameList532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationName_in_declarationNameList532	= { FOLLOW_declarationName_in_declarationNameList532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_declarationNameList536  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_declarationNameList536_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_declarationNameList536	= { FOLLOW_COMMA_in_declarationNameList536_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationName_in_declarationNameList538  */
static	ANTLR3_BITWORD FOLLOW_declarationName_in_declarationNameList538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationName_in_declarationNameList538	= { FOLLOW_declarationName_in_declarationNameList538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_declarationName562  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_declarationName562_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_declarationName562	= { FOLLOW_VALID_NAME_in_declarationName562_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anonymousObject_in_declarationName564  */
static	ANTLR3_BITWORD FOLLOW_anonymousObject_in_declarationName564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anonymousObject_in_declarationName564	= { FOLLOW_anonymousObject_in_declarationName564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_initializer586  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_initializer586_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_initializer586	= { FOLLOW_COLON_in_initializer586_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_initializer588  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_initializer588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_initializer588	= { FOLLOW_fullCommaExpression_in_initializer588_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_preScopeOperator_in_scopeOp609  */
static	ANTLR3_BITWORD FOLLOW_preScopeOperator_in_scopeOp609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_preScopeOperator_in_scopeOp609	= { FOLLOW_preScopeOperator_in_scopeOp609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postScopeOperator_in_scopeOp621  */
static	ANTLR3_BITWORD FOLLOW_postScopeOperator_in_scopeOp621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_postScopeOperator_in_scopeOp621	= { FOLLOW_postScopeOperator_in_scopeOp621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_scopeOp_in_scope_642  */
static	ANTLR3_BITWORD FOLLOW_scopeOp_in_scope_642_bits[]	= { ANTLR3_UINT64_LIT(0x4A4190686C440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_scopeOp_in_scope_642	= { FOLLOW_scopeOp_in_scope_642_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_scope_658  */
static	ANTLR3_BITWORD FOLLOW_statement_in_scope_658_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_scope_658	= { FOLLOW_statement_in_scope_658_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDENT_in_scope_678  */
static	ANTLR3_BITWORD FOLLOW_INDENT_in_scope_678_bits[]	= { ANTLR3_UINT64_LIT(0x4A41906868440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_INDENT_in_scope_678	= { FOLLOW_INDENT_in_scope_678_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_scope_680  */
static	ANTLR3_BITWORD FOLLOW_statement_in_scope_680_bits[]	= { ANTLR3_UINT64_LIT(0x4A41906868442200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_scope_680	= { FOLLOW_statement_in_scope_680_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEDENT_in_scope_683  */
static	ANTLR3_BITWORD FOLLOW_DEDENT_in_scope_683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DEDENT_in_scope_683	= { FOLLOW_DEDENT_in_scope_683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLabel_in_functionDeclaration714  */
static	ANTLR3_BITWORD FOLLOW_typeLabel_in_functionDeclaration714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLabel_in_functionDeclaration714	= { FOLLOW_typeLabel_in_functionDeclaration714_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_functionDeclaration716  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_functionDeclaration716_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_functionDeclaration716	= { FOLLOW_VALID_NAME_in_functionDeclaration716_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_functionDeclaration718  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_functionDeclaration718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000), ANTLR3_UINT64_LIT(0x0000000000000808) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_functionDeclaration718	= { FOLLOW_LPAREN_in_functionDeclaration718_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionArguments_in_functionDeclaration720  */
static	ANTLR3_BITWORD FOLLOW_functionArguments_in_functionDeclaration720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_functionArguments_in_functionDeclaration720	= { FOLLOW_functionArguments_in_functionDeclaration720_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_functionDeclaration722  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_functionDeclaration722_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000080800) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_functionDeclaration722	= { FOLLOW_RPAREN_in_functionDeclaration722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_functionDeclaration738  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_functionDeclaration738_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_functionDeclaration738	= { FOLLOW_NEWLINE_in_functionDeclaration738_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_functionDeclaration758  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_functionDeclaration758_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_functionDeclaration758	= { FOLLOW_EQUAL_in_functionDeclaration758_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_functionDeclaration760  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_functionDeclaration760_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_functionDeclaration760	= { FOLLOW_conditionalExpression_in_functionDeclaration760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_functionDeclaration762  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_functionDeclaration762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_functionDeclaration762	= { FOLLOW_NEWLINE_in_functionDeclaration762_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_functionDeclaration782  */
static	ANTLR3_BITWORD FOLLOW_block_in_functionDeclaration782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_functionDeclaration782	= { FOLLOW_block_in_functionDeclaration782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionArgument_in_functionArguments811  */
static	ANTLR3_BITWORD FOLLOW_functionArgument_in_functionArguments811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionArgument_in_functionArguments811	= { FOLLOW_functionArgument_in_functionArguments811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_functionArguments815  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_functionArguments815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_functionArguments815	= { FOLLOW_COMMA_in_functionArguments815_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionArgument_in_functionArguments817  */
static	ANTLR3_BITWORD FOLLOW_functionArgument_in_functionArguments817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionArgument_in_functionArguments817	= { FOLLOW_functionArgument_in_functionArguments817_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeLabel_in_functionArgument850  */
static	ANTLR3_BITWORD FOLLOW_typeLabel_in_functionArgument850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_typeLabel_in_functionArgument850	= { FOLLOW_typeLabel_in_functionArgument850_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_functionArgument852  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_functionArgument852_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_functionArgument852	= { FOLLOW_VALID_NAME_in_functionArgument852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_IF_in_ifStatement878  */
static	ANTLR3_BITWORD FOLLOW_KW_IF_in_ifStatement878_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_IF_in_ifStatement878	= { FOLLOW_KW_IF_in_ifStatement878_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_ifStatement880  */
static	ANTLR3_BITWORD FOLLOW_expression_in_ifStatement880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_ifStatement880	= { FOLLOW_expression_in_ifStatement880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_ifStatement896  */
static	ANTLR3_BITWORD FOLLOW_block_in_ifStatement896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_ifStatement896	= { FOLLOW_block_in_ifStatement896_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elseStatement_in_ifStatement936  */
static	ANTLR3_BITWORD FOLLOW_elseStatement_in_ifStatement936_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elseStatement_in_ifStatement936	= { FOLLOW_elseStatement_in_ifStatement936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ELSE_in_elseStatement966  */
static	ANTLR3_BITWORD FOLLOW_KW_ELSE_in_elseStatement966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ELSE_in_elseStatement966	= { FOLLOW_KW_ELSE_in_elseStatement966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_elseStatement968  */
static	ANTLR3_BITWORD FOLLOW_block_in_elseStatement968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_elseStatement968	= { FOLLOW_block_in_elseStatement968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_WHILE_in_whileStatement989  */
static	ANTLR3_BITWORD FOLLOW_KW_WHILE_in_whileStatement989_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_WHILE_in_whileStatement989	= { FOLLOW_KW_WHILE_in_whileStatement989_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_whileStatement991  */
static	ANTLR3_BITWORD FOLLOW_expression_in_whileStatement991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_whileStatement991	= { FOLLOW_expression_in_whileStatement991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_whileStatement993  */
static	ANTLR3_BITWORD FOLLOW_block_in_whileStatement993_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_whileStatement993	= { FOLLOW_block_in_whileStatement993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_BREAK_in_breakStatement1014  */
static	ANTLR3_BITWORD FOLLOW_KW_BREAK_in_breakStatement1014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_BREAK_in_breakStatement1014	= { FOLLOW_KW_BREAK_in_breakStatement1014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CONTINUE_in_continueStatement1035  */
static	ANTLR3_BITWORD FOLLOW_KW_CONTINUE_in_continueStatement1035_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CONTINUE_in_continueStatement1035	= { FOLLOW_KW_CONTINUE_in_continueStatement1035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignmentExpression_in_expression1071  */
static	ANTLR3_BITWORD FOLLOW_assignmentExpression_in_expression1071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignmentExpression_in_expression1071	= { FOLLOW_assignmentExpression_in_expression1071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleCommaExpression_in_assignmentExpression1120  */
static	ANTLR3_BITWORD FOLLOW_simpleCommaExpression_in_assignmentExpression1120_bits[]	= { ANTLR3_UINT64_LIT(0x8400000000088002), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleCommaExpression_in_assignmentExpression1120	= { FOLLOW_simpleCommaExpression_in_assignmentExpression1120_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignmentOp_in_assignmentExpression1166  */
static	ANTLR3_BITWORD FOLLOW_assignmentOp_in_assignmentExpression1166_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_assignmentOp_in_assignmentExpression1166	= { FOLLOW_assignmentOp_in_assignmentExpression1166_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleCommaExpression_in_assignmentExpression1188  */
static	ANTLR3_BITWORD FOLLOW_simpleCommaExpression_in_assignmentExpression1188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleCommaExpression_in_assignmentExpression1188	= { FOLLOW_simpleCommaExpression_in_assignmentExpression1188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_simpleCommaExpression1248  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_simpleCommaExpression1248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_simpleCommaExpression1248	= { FOLLOW_conditionalExpression_in_simpleCommaExpression1248_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_simpleCommaExpression1280  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_simpleCommaExpression1280_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_simpleCommaExpression1280	= { FOLLOW_COMMA_in_simpleCommaExpression1280_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_simpleCommaExpression1292  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_simpleCommaExpression1292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_simpleCommaExpression1292	= { FOLLOW_conditionalExpression_in_simpleCommaExpression1292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_simpleCommaExpression1315  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_simpleCommaExpression1315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_simpleCommaExpression1315	= { FOLLOW_COMMA_in_simpleCommaExpression1315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_commaExpressionElem_in_fullCommaExpression1339  */
static	ANTLR3_BITWORD FOLLOW_commaExpressionElem_in_fullCommaExpression1339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_commaExpressionElem_in_fullCommaExpression1339	= { FOLLOW_commaExpressionElem_in_fullCommaExpression1339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_fullCommaExpression1347  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_fullCommaExpression1347_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_fullCommaExpression1347	= { FOLLOW_COMMA_in_fullCommaExpression1347_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_commaExpressionElem_in_fullCommaExpression1349  */
static	ANTLR3_BITWORD FOLLOW_commaExpressionElem_in_fullCommaExpression1349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_commaExpressionElem_in_fullCommaExpression1349	= { FOLLOW_commaExpressionElem_in_fullCommaExpression1349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_fullCommaExpression1358  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_fullCommaExpression1358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_fullCommaExpression1358	= { FOLLOW_COMMA_in_fullCommaExpression1358_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_commaExpressionElem1380  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_commaExpressionElem1380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_commaExpressionElem1380	= { FOLLOW_conditionalExpression_in_commaExpressionElem1380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_commaExpressionElem1388  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_commaExpressionElem1388_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_commaExpressionElem1388	= { FOLLOW_EQUAL_in_commaExpressionElem1388_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalExpression_in_commaExpressionElem1390  */
static	ANTLR3_BITWORD FOLLOW_conditionalExpression_in_commaExpressionElem1390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalExpression_in_commaExpressionElem1390	= { FOLLOW_conditionalExpression_in_commaExpressionElem1390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicOrExpression_in_conditionalExpression1436  */
static	ANTLR3_BITWORD FOLLOW_logicOrExpression_in_conditionalExpression1436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_logicOrExpression_in_conditionalExpression1436	= { FOLLOW_logicOrExpression_in_conditionalExpression1436_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QMARK_in_conditionalExpression1468  */
static	ANTLR3_BITWORD FOLLOW_QMARK_in_conditionalExpression1468_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_QMARK_in_conditionalExpression1468	= { FOLLOW_QMARK_in_conditionalExpression1468_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicOrExpression_in_conditionalExpression1480  */
static	ANTLR3_BITWORD FOLLOW_logicOrExpression_in_conditionalExpression1480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_logicOrExpression_in_conditionalExpression1480	= { FOLLOW_logicOrExpression_in_conditionalExpression1480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_conditionalExpression1490  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_conditionalExpression1490_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_conditionalExpression1490	= { FOLLOW_COLON_in_conditionalExpression1490_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicOrExpression_in_conditionalExpression1502  */
static	ANTLR3_BITWORD FOLLOW_logicOrExpression_in_conditionalExpression1502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logicOrExpression_in_conditionalExpression1502	= { FOLLOW_logicOrExpression_in_conditionalExpression1502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicAndExpression_in_logicOrExpression1562  */
static	ANTLR3_BITWORD FOLLOW_logicAndExpression_in_logicOrExpression1562_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logicAndExpression_in_logicOrExpression1562	= { FOLLOW_logicAndExpression_in_logicOrExpression1562_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_OR_in_logicOrExpression1594  */
static	ANTLR3_BITWORD FOLLOW_KW_OR_in_logicOrExpression1594_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_OR_in_logicOrExpression1594	= { FOLLOW_KW_OR_in_logicOrExpression1594_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicAndExpression_in_logicOrExpression1606  */
static	ANTLR3_BITWORD FOLLOW_logicAndExpression_in_logicOrExpression1606_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logicAndExpression_in_logicOrExpression1606	= { FOLLOW_logicAndExpression_in_logicOrExpression1606_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalityExpression_in_logicAndExpression1666  */
static	ANTLR3_BITWORD FOLLOW_equalityExpression_in_logicAndExpression1666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_equalityExpression_in_logicAndExpression1666	= { FOLLOW_equalityExpression_in_logicAndExpression1666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_AND_in_logicAndExpression1698  */
static	ANTLR3_BITWORD FOLLOW_KW_AND_in_logicAndExpression1698_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_AND_in_logicAndExpression1698	= { FOLLOW_KW_AND_in_logicAndExpression1698_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalityExpression_in_logicAndExpression1710  */
static	ANTLR3_BITWORD FOLLOW_equalityExpression_in_logicAndExpression1710_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_equalityExpression_in_logicAndExpression1710	= { FOLLOW_equalityExpression_in_logicAndExpression1710_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparisonExpression_in_equalityExpression1769  */
static	ANTLR3_BITWORD FOLLOW_comparisonExpression_in_equalityExpression1769_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000100002) };
static  ANTLR3_BITSET_LIST FOLLOW_comparisonExpression_in_equalityExpression1769	= { FOLLOW_comparisonExpression_in_equalityExpression1769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eqOp_in_equalityExpression1801  */
static	ANTLR3_BITWORD FOLLOW_eqOp_in_equalityExpression1801_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_eqOp_in_equalityExpression1801	= { FOLLOW_eqOp_in_equalityExpression1801_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparisonExpression_in_equalityExpression1813  */
static	ANTLR3_BITWORD FOLLOW_comparisonExpression_in_equalityExpression1813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comparisonExpression_in_equalityExpression1813	= { FOLLOW_comparisonExpression_in_equalityExpression1813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitOrExpression_in_comparisonExpression1872  */
static	ANTLR3_BITWORD FOLLOW_bitOrExpression_in_comparisonExpression1872_bits[]	= { ANTLR3_UINT64_LIT(0x0018000001800002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitOrExpression_in_comparisonExpression1872	= { FOLLOW_bitOrExpression_in_comparisonExpression1872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparisonOp_in_comparisonExpression1904  */
static	ANTLR3_BITWORD FOLLOW_comparisonOp_in_comparisonExpression1904_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_comparisonOp_in_comparisonExpression1904	= { FOLLOW_comparisonOp_in_comparisonExpression1904_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitOrExpression_in_comparisonExpression1916  */
static	ANTLR3_BITWORD FOLLOW_bitOrExpression_in_comparisonExpression1916_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitOrExpression_in_comparisonExpression1916	= { FOLLOW_bitOrExpression_in_comparisonExpression1916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitXorExpression_in_bitOrExpression1975  */
static	ANTLR3_BITWORD FOLLOW_bitXorExpression_in_bitOrExpression1975_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitXorExpression_in_bitOrExpression1975	= { FOLLOW_bitXorExpression_in_bitOrExpression1975_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PIPE_in_bitOrExpression2007  */
static	ANTLR3_BITWORD FOLLOW_PIPE_in_bitOrExpression2007_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_PIPE_in_bitOrExpression2007	= { FOLLOW_PIPE_in_bitOrExpression2007_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitXorExpression_in_bitOrExpression2019  */
static	ANTLR3_BITWORD FOLLOW_bitXorExpression_in_bitOrExpression2019_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitXorExpression_in_bitOrExpression2019	= { FOLLOW_bitXorExpression_in_bitOrExpression2019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitAndExpression_in_bitXorExpression2078  */
static	ANTLR3_BITWORD FOLLOW_bitAndExpression_in_bitXorExpression2078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_bitAndExpression_in_bitXorExpression2078	= { FOLLOW_bitAndExpression_in_bitXorExpression2078_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CIRCUMFLEX_in_bitXorExpression2110  */
static	ANTLR3_BITWORD FOLLOW_CIRCUMFLEX_in_bitXorExpression2110_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_CIRCUMFLEX_in_bitXorExpression2110	= { FOLLOW_CIRCUMFLEX_in_bitXorExpression2110_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitAndExpression_in_bitXorExpression2122  */
static	ANTLR3_BITWORD FOLLOW_bitAndExpression_in_bitXorExpression2122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_bitAndExpression_in_bitXorExpression2122	= { FOLLOW_bitAndExpression_in_bitXorExpression2122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_shiftExpression_in_bitAndExpression2181  */
static	ANTLR3_BITWORD FOLLOW_shiftExpression_in_bitAndExpression2181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_shiftExpression_in_bitAndExpression2181	= { FOLLOW_shiftExpression_in_bitAndExpression2181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_bitAndExpression2213  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_bitAndExpression2213_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_bitAndExpression2213	= { FOLLOW_AMPERSAND_in_bitAndExpression2213_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_shiftExpression_in_bitAndExpression2225  */
static	ANTLR3_BITWORD FOLLOW_shiftExpression_in_bitAndExpression2225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_shiftExpression_in_bitAndExpression2225	= { FOLLOW_shiftExpression_in_bitAndExpression2225_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addExpression_in_shiftExpression2284  */
static	ANTLR3_BITWORD FOLLOW_addExpression_in_shiftExpression2284_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000002), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_addExpression_in_shiftExpression2284	= { FOLLOW_addExpression_in_shiftExpression2284_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_shiftOp_in_shiftExpression2316  */
static	ANTLR3_BITWORD FOLLOW_shiftOp_in_shiftExpression2316_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_shiftOp_in_shiftExpression2316	= { FOLLOW_shiftOp_in_shiftExpression2316_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addExpression_in_shiftExpression2328  */
static	ANTLR3_BITWORD FOLLOW_addExpression_in_shiftExpression2328_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000002), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_addExpression_in_shiftExpression2328	= { FOLLOW_addExpression_in_shiftExpression2328_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multExpression_in_addExpression2387  */
static	ANTLR3_BITWORD FOLLOW_multExpression_in_addExpression2387_bits[]	= { ANTLR3_UINT64_LIT(0x4200000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multExpression_in_addExpression2387	= { FOLLOW_multExpression_in_addExpression2387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addOp_in_addExpression2435  */
static	ANTLR3_BITWORD FOLLOW_addOp_in_addExpression2435_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_addOp_in_addExpression2435	= { FOLLOW_addOp_in_addExpression2435_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multExpression_in_addExpression2447  */
static	ANTLR3_BITWORD FOLLOW_multExpression_in_addExpression2447_bits[]	= { ANTLR3_UINT64_LIT(0x4200000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multExpression_in_addExpression2447	= { FOLLOW_multExpression_in_addExpression2447_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpression_in_multExpression2506  */
static	ANTLR3_BITWORD FOLLOW_unaryExpression_in_multExpression2506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022), ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpression_in_multExpression2506	= { FOLLOW_unaryExpression_in_multExpression2506_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multOp_in_multExpression2538  */
static	ANTLR3_BITWORD FOLLOW_multOp_in_multExpression2538_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_multOp_in_multExpression2538	= { FOLLOW_multOp_in_multExpression2538_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpression_in_multExpression2550  */
static	ANTLR3_BITWORD FOLLOW_unaryExpression_in_multExpression2550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022), ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpression_in_multExpression2550	= { FOLLOW_unaryExpression_in_multExpression2550_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryOp_in_unaryExpression2597  */
static	ANTLR3_BITWORD FOLLOW_unaryOp_in_unaryExpression2597_bits[]	= { ANTLR3_UINT64_LIT(0x0041100808400200), ANTLR3_UINT64_LIT(0x0000000000000880) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryOp_in_unaryExpression2597	= { FOLLOW_unaryOp_in_unaryExpression2597_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postfixExpression_in_unaryExpression2600  */
static	ANTLR3_BITWORD FOLLOW_postfixExpression_in_unaryExpression2600_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_postfixExpression_in_unaryExpression2600	= { FOLLOW_postfixExpression_in_unaryExpression2600_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomExpression_in_postfixExpression2621  */
static	ANTLR3_BITWORD FOLLOW_atomExpression_in_postfixExpression2621_bits[]	= { ANTLR3_UINT64_LIT(0x0042000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomExpression_in_postfixExpression2621	= { FOLLOW_atomExpression_in_postfixExpression2621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postfixOperation_in_postfixExpression2623  */
static	ANTLR3_BITWORD FOLLOW_postfixOperation_in_postfixExpression2623_bits[]	= { ANTLR3_UINT64_LIT(0x0042000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_postfixOperation_in_postfixExpression2623	= { FOLLOW_postfixOperation_in_postfixExpression2623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_atomExpression2645  */
static	ANTLR3_BITWORD FOLLOW_literal_in_atomExpression2645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_atomExpression2645	= { FOLLOW_literal_in_atomExpression2645_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_atomExpression2657  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_atomExpression2657_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_atomExpression2657	= { FOLLOW_identifier_in_atomExpression2657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_atomExpression2669  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_atomExpression2669_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_atomExpression2669	= { FOLLOW_LPAREN_in_atomExpression2669_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_atomExpression2671  */
static	ANTLR3_BITWORD FOLLOW_expression_in_atomExpression2671_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_atomExpression2671	= { FOLLOW_expression_in_atomExpression2671_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_atomExpression2673  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_atomExpression2673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_atomExpression2673	= { FOLLOW_RPAREN_in_atomExpression2673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anonymousObject_in_atomExpression2685  */
static	ANTLR3_BITWORD FOLLOW_anonymousObject_in_atomExpression2685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anonymousObject_in_atomExpression2685	= { FOLLOW_anonymousObject_in_atomExpression2685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACE_in_anonymousObject2706  */
static	ANTLR3_BITWORD FOLLOW_LBRACE_in_anonymousObject2706_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000982) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACE_in_anonymousObject2706	= { FOLLOW_LBRACE_in_anonymousObject2706_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_anonymousObject2708  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_anonymousObject2708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_anonymousObject2708	= { FOLLOW_fullCommaExpression_in_anonymousObject2708_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACE_in_anonymousObject2711  */
static	ANTLR3_BITWORD FOLLOW_RBRACE_in_anonymousObject2711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACE_in_anonymousObject2711	= { FOLLOW_RBRACE_in_anonymousObject2711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ON_in_observerStatement2736  */
static	ANTLR3_BITWORD FOLLOW_KW_ON_in_observerStatement2736_bits[]	= { ANTLR3_UINT64_LIT(0x00002F0380000000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ON_in_observerStatement2736	= { FOLLOW_KW_ON_in_observerStatement2736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventMask_in_observerStatement2738  */
static	ANTLR3_BITWORD FOLLOW_eventMask_in_observerStatement2738_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_eventMask_in_observerStatement2738	= { FOLLOW_eventMask_in_observerStatement2738_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_observerStatement2740  */
static	ANTLR3_BITWORD FOLLOW_expression_in_observerStatement2740_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_observerStatement2740	= { FOLLOW_expression_in_observerStatement2740_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_observerStatement2744  */
static	ANTLR3_BITWORD FOLLOW_block_in_observerStatement2744_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_observerStatement2744	= { FOLLOW_block_in_observerStatement2744_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_observerStatement2748  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_observerStatement2748_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_observerStatement2748	= { FOLLOW_NEWLINE_in_observerStatement2748_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventFlag_in_eventMask2771  */
static	ANTLR3_BITWORD FOLLOW_eventFlag_in_eventMask2771_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_eventFlag_in_eventMask2771	= { FOLLOW_eventFlag_in_eventMask2771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PIPE_in_eventMask2775  */
static	ANTLR3_BITWORD FOLLOW_PIPE_in_eventMask2775_bits[]	= { ANTLR3_UINT64_LIT(0x00002F0380000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PIPE_in_eventMask2775	= { FOLLOW_PIPE_in_eventMask2775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventFlag_in_eventMask2777  */
static	ANTLR3_BITWORD FOLLOW_eventFlag_in_eventMask2777_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_eventFlag_in_eventMask2777	= { FOLLOW_eventFlag_in_eventMask2777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventBaseFlag_in_eventFlag2793  */
static	ANTLR3_BITWORD FOLLOW_eventBaseFlag_in_eventFlag2793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_eventBaseFlag_in_eventFlag2793	= { FOLLOW_eventBaseFlag_in_eventFlag2793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventScopeFlag_in_eventFlag2797  */
static	ANTLR3_BITWORD FOLLOW_eventScopeFlag_in_eventFlag2797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_eventScopeFlag_in_eventFlag2797	= { FOLLOW_eventScopeFlag_in_eventFlag2797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionCall_in_postfixOperation3121  */
static	ANTLR3_BITWORD FOLLOW_functionCall_in_postfixOperation3121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionCall_in_postfixOperation3121	= { FOLLOW_functionCall_in_postfixOperation3121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_memberAccess_in_postfixOperation3133  */
static	ANTLR3_BITWORD FOLLOW_memberAccess_in_postfixOperation3133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_memberAccess_in_postfixOperation3133	= { FOLLOW_memberAccess_in_postfixOperation3133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elementAccess_in_postfixOperation3145  */
static	ANTLR3_BITWORD FOLLOW_elementAccess_in_postfixOperation3145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elementAccess_in_postfixOperation3145	= { FOLLOW_elementAccess_in_postfixOperation3145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_functionCall3166  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_functionCall3166_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000988) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_functionCall3166	= { FOLLOW_LPAREN_in_functionCall3166_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_functionCall3168  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_functionCall3168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_functionCall3168	= { FOLLOW_fullCommaExpression_in_functionCall3168_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_functionCall3171  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_functionCall3171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_functionCall3171	= { FOLLOW_RPAREN_in_functionCall3171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_memberAccess3192  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_memberAccess3192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_memberAccess3192	= { FOLLOW_DOT_in_memberAccess3192_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_memberAccess3194  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_memberAccess3194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_memberAccess3194	= { FOLLOW_VALID_NAME_in_memberAccess3194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_in_elementAccess3215  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_in_elementAccess3215_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000984) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_in_elementAccess3215	= { FOLLOW_LBRACK_in_elementAccess3215_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fullCommaExpression_in_elementAccess3217  */
static	ANTLR3_BITWORD FOLLOW_fullCommaExpression_in_elementAccess3217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_fullCommaExpression_in_elementAccess3217	= { FOLLOW_fullCommaExpression_in_elementAccess3217_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_in_elementAccess3220  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_in_elementAccess3220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_in_elementAccess3220	= { FOLLOW_RBRACK_in_elementAccess3220_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_COLON_in_postScopeOperator3233  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_COLON_in_postScopeOperator3233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_COLON_in_postScopeOperator3233	= { FOLLOW_DOUBLE_COLON_in_postScopeOperator3233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRIPLE_COLON_in_preScopeOperator3241  */
static	ANTLR3_BITWORD FOLLOW_TRIPLE_COLON_in_preScopeOperator3241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRIPLE_COLON_in_preScopeOperator3241	= { FOLLOW_TRIPLE_COLON_in_preScopeOperator3241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALID_NAME_in_constant3262  */
static	ANTLR3_BITWORD FOLLOW_VALID_NAME_in_constant3262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALID_NAME_in_constant3262	= { FOLLOW_VALID_NAME_in_constant3262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GID_in_constant3274  */
static	ANTLR3_BITWORD FOLLOW_GID_in_constant3274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GID_in_constant3274	= { FOLLOW_GID_in_constant3274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_constant3286  */
static	ANTLR3_BITWORD FOLLOW_literal_in_constant3286_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_constant3286	= { FOLLOW_literal_in_constant3286_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_typeLabel3340  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_typeLabel3340_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_typeLabel3340	= { FOLLOW_identifier_in_typeLabel3340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anonymousObject_in_typeLabel3342  */
static	ANTLR3_BITWORD FOLLOW_anonymousObject_in_typeLabel3342_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anonymousObject_in_typeLabel3342	= { FOLLOW_anonymousObject_in_typeLabel3342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_booleanLiteral_in_literal3364  */
static	ANTLR3_BITWORD FOLLOW_booleanLiteral_in_literal3364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_booleanLiteral_in_literal3364	= { FOLLOW_booleanLiteral_in_literal3364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHARACTER_in_literal3376  */
static	ANTLR3_BITWORD FOLLOW_CHARACTER_in_literal3376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHARACTER_in_literal3376	= { FOLLOW_CHARACTER_in_literal3376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_literal3388  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_literal3388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_literal3388	= { FOLLOW_INTEGER_in_literal3388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_literal3400  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_literal3400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_literal3400	= { FOLLOW_STRING_in_literal3400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarativeStatement_in_synpred1_Cortolang183  */
static	ANTLR3_BITWORD FOLLOW_declarativeStatement_in_synpred1_Cortolang183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarativeStatement_in_synpred1_Cortolang183	= { FOLLOW_declarativeStatement_in_synpred1_Cortolang183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_synpred2_Cortolang264  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_synpred2_Cortolang264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_synpred2_Cortolang264	= { FOLLOW_functionDeclaration_in_synpred2_Cortolang264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declarationExt_in_synpred3_Cortolang286  */
static	ANTLR3_BITWORD FOLLOW_declarationExt_in_synpred3_Cortolang286_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declarationExt_in_synpred3_Cortolang286	= { FOLLOW_declarationExt_in_synpred3_Cortolang286_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ELSE_in_synpred4_Cortolang920  */
static	ANTLR3_BITWORD FOLLOW_KW_ELSE_in_synpred4_Cortolang920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ELSE_in_synpred4_Cortolang920	= { FOLLOW_KW_ELSE_in_synpred4_Cortolang920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addOp_in_synpred5_Cortolang2420  */
static	ANTLR3_BITWORD FOLLOW_addOp_in_synpred5_Cortolang2420_bits[]	= { ANTLR3_UINT64_LIT(0x4241100808440200), ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_addOp_in_synpred5_Cortolang2420	= { FOLLOW_addOp_in_synpred5_Cortolang2420_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multExpression_in_synpred5_Cortolang2422  */
static	ANTLR3_BITWORD FOLLOW_multExpression_in_synpred5_Cortolang2422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multExpression_in_synpred5_Cortolang2422	= { FOLLOW_multExpression_in_synpred5_Cortolang2422_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * Cortolang.g:47:1: program returns [ parser_ProgramNode ___ node ] : ( statement )+ ;
 */
static parser_ProgramNode ___
program(pCortolangParser ctx)
{
    parser_ProgramNode ___ node;


    parser_StatementNode ___ statement1;
    #undef	RETURN_TYPE_statement1
    #define	RETURN_TYPE_statement1 parser_StatementNode ___

    /* Initialize rule variables
     */


        node = parser_ProgramNodeCreate(0, 0, corto_llNew());

    {
        // Cortolang.g:53:5: ( ( statement )+ )
        // Cortolang.g:54:5: ( statement )+
        {
            // Cortolang.g:54:5: ( statement )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) )
            	{
            	case CHARACTER:
            	case EMARK:
            	case GID:
            	case INTEGER:
            	case KW_BREAK:
            	case KW_CONTINUE:
            	case KW_FALSE:
            	case KW_IF:
            	case KW_ON:
            	case KW_TRUE:
            	case KW_WHILE:
            	case LBRACE:
            	case LPAREN:
            	case MINUS:
            	case NEWLINE:
            	case PLUS:
            	case STRING:
            	case TILDE:
            	case VALID_NAME:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1)
            	{
            	    case 1:
            	        // Cortolang.g:55:9: statement
            	        {
            	            FOLLOWPUSH(FOLLOW_statement_in_program135);
            	            statement1=statement(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return node;
            	            }


            	            if ( BACKTRACKING==0 )
            	            {

            	                            if (statement1
            	                ) {
            	                                corto_llAppend(node->statements, statement1
            	                );
            	                            }
            	                        
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return node;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleprogramEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end program */

/**
 * $ANTLR start statement
 * Cortolang.g:64:1: statement returns [ parser_StatementNode ___ node ] : ( ( declarativeStatement )=> declarativeStatement | simpleStatement NEWLINE | compositeStatement | NEWLINE );
 */
static parser_StatementNode ___
statement(pCortolangParser ctx)
{
    parser_StatementNode ___ node;


    parser_StatementNode ___ simpleStatement2;
    #undef	RETURN_TYPE_simpleStatement2
    #define	RETURN_TYPE_simpleStatement2 parser_StatementNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        {
            //  Cortolang.g:70:5: ( ( declarativeStatement )=> declarativeStatement | simpleStatement NEWLINE | compositeStatement | NEWLINE )

            ANTLR3_UINT32 alt2;

            alt2=4;

            switch ( LA(1) )
            {
            case GID:
            case VALID_NAME:
            	{
            		{
            		    int LA2_1 = LA(2);
            		    if ( (synpred1_Cortolang(ctx)) && (LA2_1 == LBRACE))
            		    {
            		        alt2=1;
            		    }
            		    else if ( (synpred1_Cortolang(ctx)) && (LA2_1 == VALID_NAME))
            		    {
            		        alt2=1;
            		    }
            		    else if ( (((LA2_1 >= AMPERSAND) && (LA2_1 <= ASTERISK)) || LA2_1 == CIRCUMFLEX || LA2_1 == COMMA || ((LA2_1 >= DIV_EQUAL) && (LA2_1 <= DOT)) || ((LA2_1 >= EQUAL) && (LA2_1 <= EQUALS)) || ((LA2_1 >= GREATER_THAN) && (LA2_1 <= GREATER_THAN_EQUAL)) || LA2_1 == KW_AND || LA2_1 == KW_OR || LA2_1 == LBRACK || ((LA2_1 >= LESS_THAN) && (LA2_1 <= LESS_THAN_EQUAL)) || ((LA2_1 >= LPAREN) && (LA2_1 <= LSHIFT)) || ((LA2_1 >= MINUS) && (LA2_1 <= QMARK)) || LA2_1 == RSHIFT || LA2_1 == SLASH || LA2_1 == TIMES_EQUAL))
            		    {
            		        alt2=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return node;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 2;
            		        EXCEPTION->state        = 1;


            		        goto rulestatementEx;

            		    }
            		}
            	}
                break;
            case CHARACTER:
            case EMARK:
            case INTEGER:
            case KW_BREAK:
            case KW_CONTINUE:
            case KW_FALSE:
            case KW_TRUE:
            case LBRACE:
            case LPAREN:
            case MINUS:
            case PLUS:
            case STRING:
            case TILDE:
            	{
            		alt2=2;
            	}
                break;
            case KW_IF:
            case KW_ON:
            case KW_WHILE:
            	{
            		alt2=3;
            	}
                break;
            case NEWLINE:
            	{
            		alt2=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return node;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // Cortolang.g:71:5: ( declarativeStatement )=> declarativeStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_declarativeStatement_in_statement192);
        	        declarativeStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:74:5: simpleStatement NEWLINE
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleStatement_in_statement204);
        	        simpleStatement2=simpleStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_statement206);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    node = simpleStatement2
        	            ;
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:79:5: compositeStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_compositeStatement_in_statement224);
        	        compositeStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:82:5: NEWLINE
        	    {
        	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_statement242);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end statement */

/**
 * $ANTLR start declarativeStatement
 * Cortolang.g:85:1: declarativeStatement : ( ( functionDeclaration )=> functionDeclaration | ( declarationExt )=> declarationExt );
 */
static void
declarativeStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:86:5: ( ( functionDeclaration )=> functionDeclaration | ( declarationExt )=> declarationExt )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case GID:
            case VALID_NAME:
            	{
            		{
            		    int LA3_1 = LA(2);
            		    if ( (synpred2_Cortolang(ctx)))
            		    {
            		        alt3=1;
            		    }
            		    else if ( (synpred3_Cortolang(ctx)))
            		    {
            		        alt3=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 3;
            		        EXCEPTION->state        = 1;


            		        goto ruledeclarativeStatementEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruledeclarativeStatementEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // Cortolang.g:87:5: ( functionDeclaration )=> functionDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_functionDeclaration_in_declarativeStatement273);
        	        functionDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarativeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:90:5: ( declarationExt )=> declarationExt
        	    {
        	        FOLLOWPUSH(FOLLOW_declarationExt_in_declarativeStatement295);
        	        declarationExt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarativeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclarativeStatementEx; /* Prevent compiler warnings */
    ruledeclarativeStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declarativeStatement */

/**
 * $ANTLR start simpleStatement
 * Cortolang.g:94:1: simpleStatement returns [ parser_StatementNode ___ node ] : (e= expression | breakStatement | continueStatement );
 */
static parser_StatementNode ___
simpleStatement(pCortolangParser ctx)
{
    parser_StatementNode ___ node;


    parser_ExpressionNode ___ e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        {
            //  Cortolang.g:100:5: (e= expression | breakStatement | continueStatement )

            ANTLR3_UINT32 alt4;

            alt4=3;

            switch ( LA(1) )
            {
            case CHARACTER:
            case EMARK:
            case GID:
            case INTEGER:
            case KW_FALSE:
            case KW_TRUE:
            case LBRACE:
            case LPAREN:
            case MINUS:
            case PLUS:
            case STRING:
            case TILDE:
            case VALID_NAME:
            	{
            		alt4=1;
            	}
                break;
            case KW_BREAK:
            	{
            		alt4=2;
            	}
                break;
            case KW_CONTINUE:
            	{
            		alt4=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return node;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto rulesimpleStatementEx;

            }

            switch (alt4)
            {
        	case 1:
        	    // Cortolang.g:101:5: e= expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_simpleStatement327);
        	        e=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	                    // TODO line and column
        	                    parser_ExpressionStatementNode _node = parser_ExpressionStatementNodeCreate(
        	                        0, 0, e

        	                    );
        	                    node = parser_StatementNode(_node);
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:110:5: breakStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_breakStatement_in_simpleStatement345);
        	        breakStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:112:5: continueStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_continueStatement_in_simpleStatement357);
        	        continueStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return node;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleStatementEx; /* Prevent compiler warnings */
    rulesimpleStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end simpleStatement */

/**
 * $ANTLR start compositeStatement
 * Cortolang.g:115:1: compositeStatement : ( ifStatement | whileStatement | observerStatement );
 */
static void
compositeStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:116:5: ( ifStatement | whileStatement | observerStatement )

            ANTLR3_UINT32 alt5;

            alt5=3;

            switch ( LA(1) )
            {
            case KW_IF:
            	{
            		alt5=1;
            	}
                break;
            case KW_WHILE:
            	{
            		alt5=2;
            	}
                break;
            case KW_ON:
            	{
            		alt5=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rulecompositeStatementEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // Cortolang.g:117:5: ifStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_ifStatement_in_compositeStatement378);
        	        ifStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompositeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:119:5: whileStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_whileStatement_in_compositeStatement390);
        	        whileStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompositeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:121:5: observerStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_observerStatement_in_compositeStatement402);
        	        observerStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecompositeStatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecompositeStatementEx; /* Prevent compiler warnings */
    rulecompositeStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end compositeStatement */

/**
 * $ANTLR start block
 * Cortolang.g:124:1: block : COLON ( statement | INDENT ( statement )+ DEDENT ) ;
 */
static void
block(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:125:5: ( COLON ( statement | INDENT ( statement )+ DEDENT ) )
        // Cortolang.g:126:5: COLON ( statement | INDENT ( statement )+ DEDENT )
        {
             MATCHT(COLON, &FOLLOW_COLON_in_block423);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:127:5: ( statement | INDENT ( statement )+ DEDENT )
            {
                int alt7=2;
                switch ( LA(1) )
                {
                case CHARACTER:
                case EMARK:
                case GID:
                case INTEGER:
                case KW_BREAK:
                case KW_CONTINUE:
                case KW_FALSE:
                case KW_IF:
                case KW_ON:
                case KW_TRUE:
                case KW_WHILE:
                case LBRACE:
                case LPAREN:
                case MINUS:
                case NEWLINE:
                case PLUS:
                case STRING:
                case TILDE:
                case VALID_NAME:
                	{
                		alt7=1;
                	}
                    break;
                case INDENT:
                	{
                		alt7=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 7;
                    EXCEPTION->state        = 0;


                    goto ruleblockEx;

                }

                switch (alt7)
                {
            	case 1:
            	    // Cortolang.g:128:9: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_block439);
            	        statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:130:9: INDENT ( statement )+ DEDENT
            	    {
            	         MATCHT(INDENT, &FOLLOW_INDENT_in_block459);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        // Cortolang.g:130:16: ( statement )+
            	        {
            	            int cnt6=0;

            	            for (;;)
            	            {
            	                int alt6=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case CHARACTER:
            	        	case EMARK:
            	        	case GID:
            	        	case INTEGER:
            	        	case KW_BREAK:
            	        	case KW_CONTINUE:
            	        	case KW_FALSE:
            	        	case KW_IF:
            	        	case KW_ON:
            	        	case KW_TRUE:
            	        	case KW_WHILE:
            	        	case LBRACE:
            	        	case LPAREN:
            	        	case MINUS:
            	        	case NEWLINE:
            	        	case PLUS:
            	        	case STRING:
            	        	case TILDE:
            	        	case VALID_NAME:
            	        		{
            	        			alt6=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt6)
            	        	{
            	        	    case 1:
            	        	        // Cortolang.g:130:16: statement
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_statement_in_block461);
            	        	            statement(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleblockEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return ;
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt6 >= 1 )
            	        		{
            	        		    goto loop6;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    return ;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruleblockEx;
            	        	}
            	        	cnt6++;
            	            }
            	            loop6: ;	/* Jump to here if this rule does not match */
            	        }

            	         MATCHT(DEDENT, &FOLLOW_DEDENT_in_block464);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end block */

/**
 * $ANTLR start declarationExt
 * Cortolang.g:153:1: declarationExt : typeLabel declarationNameList ( initializer )? ( NEWLINE | scope_ ) ;
 */
static void
declarationExt(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:154:5: ( typeLabel declarationNameList ( initializer )? ( NEWLINE | scope_ ) )
        // Cortolang.g:155:5: typeLabel declarationNameList ( initializer )? ( NEWLINE | scope_ )
        {
            FOLLOWPUSH(FOLLOW_typeLabel_in_declarationExt498);
            typeLabel(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclarationExtEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_declarationNameList_in_declarationExt500);
            declarationNameList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclarationExtEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:155:35: ( initializer )?
            {
                int alt8=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8)
                {
            	case 1:
            	    // Cortolang.g:155:35: initializer
            	    {
            	        FOLLOWPUSH(FOLLOW_initializer_in_declarationExt502);
            	        initializer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationExtEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // Cortolang.g:155:48: ( NEWLINE | scope_ )
            {
                int alt9=2;
                switch ( LA(1) )
                {
                case NEWLINE:
                	{
                		alt9=1;
                	}
                    break;
                case DOUBLE_COLON:
                case TRIPLE_COLON:
                	{
                		alt9=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 9;
                    EXCEPTION->state        = 0;


                    goto ruledeclarationExtEx;

                }

                switch (alt9)
                {
            	case 1:
            	    // Cortolang.g:155:49: NEWLINE
            	    {
            	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_declarationExt506);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationExtEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:155:59: scope_
            	    {
            	        FOLLOWPUSH(FOLLOW_scope__in_declarationExt510);
            	        scope_(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationExtEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationExtEx; /* Prevent compiler warnings */
    ruledeclarationExtEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declarationExt */

/**
 * $ANTLR start declarationNameList
 * Cortolang.g:158:1: declarationNameList : declarationName ( COMMA declarationName )* ;
 */
static void
declarationNameList(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:159:5: ( declarationName ( COMMA declarationName )* )
        // Cortolang.g:160:5: declarationName ( COMMA declarationName )*
        {
            FOLLOWPUSH(FOLLOW_declarationName_in_declarationNameList532);
            declarationName(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclarationNameListEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:160:21: ( COMMA declarationName )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10)
                {
            	case 1:
            	    // Cortolang.g:160:23: COMMA declarationName
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_declarationNameList536);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationNameListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_declarationName_in_declarationNameList538);
            	        declarationName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationNameListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationNameListEx; /* Prevent compiler warnings */
    ruledeclarationNameListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declarationNameList */

/**
 * $ANTLR start declarationName
 * Cortolang.g:163:1: declarationName : VALID_NAME ( anonymousObject )? ;
 */
static void
declarationName(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:164:5: ( VALID_NAME ( anonymousObject )? )
        // Cortolang.g:165:5: VALID_NAME ( anonymousObject )?
        {
             MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_declarationName562);
            if  (HASEXCEPTION())
            {
                goto ruledeclarationNameEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:165:16: ( anonymousObject )?
            {
                int alt11=2;
                switch ( LA(1) )
                {
                    case LBRACE:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                switch (alt11)
                {
            	case 1:
            	    // Cortolang.g:165:16: anonymousObject
            	    {
            	        FOLLOWPUSH(FOLLOW_anonymousObject_in_declarationName564);
            	        anonymousObject(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclarationNameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationNameEx; /* Prevent compiler warnings */
    ruledeclarationNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declarationName */

/**
 * $ANTLR start initializer
 * Cortolang.g:168:1: initializer : COLON fullCommaExpression ;
 */
static void
initializer(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:169:5: ( COLON fullCommaExpression )
        // Cortolang.g:170:5: COLON fullCommaExpression
        {
             MATCHT(COLON, &FOLLOW_COLON_in_initializer586);
            if  (HASEXCEPTION())
            {
                goto ruleinitializerEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_fullCommaExpression_in_initializer588);
            fullCommaExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinitializerEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinitializerEx; /* Prevent compiler warnings */
    ruleinitializerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end initializer */

/**
 * $ANTLR start scopeOp
 * Cortolang.g:173:1: scopeOp : ( preScopeOperator | postScopeOperator );
 */
static void
scopeOp(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:174:5: ( preScopeOperator | postScopeOperator )

            ANTLR3_UINT32 alt12;

            alt12=2;

            switch ( LA(1) )
            {
            case TRIPLE_COLON:
            	{
            		alt12=1;
            	}
                break;
            case DOUBLE_COLON:
            	{
            		alt12=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto rulescopeOpEx;

            }

            switch (alt12)
            {
        	case 1:
        	    // Cortolang.g:175:5: preScopeOperator
        	    {
        	        FOLLOWPUSH(FOLLOW_preScopeOperator_in_scopeOp609);
        	        preScopeOperator(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulescopeOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:177:5: postScopeOperator
        	    {
        	        FOLLOWPUSH(FOLLOW_postScopeOperator_in_scopeOp621);
        	        postScopeOperator(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulescopeOpEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulescopeOpEx; /* Prevent compiler warnings */
    rulescopeOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end scopeOp */

/**
 * $ANTLR start scope_
 * Cortolang.g:180:1: scope_ : scopeOp ( statement | INDENT ( statement )+ DEDENT ) ;
 */
static void
scope_(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:181:5: ( scopeOp ( statement | INDENT ( statement )+ DEDENT ) )
        // Cortolang.g:182:5: scopeOp ( statement | INDENT ( statement )+ DEDENT )
        {
            FOLLOWPUSH(FOLLOW_scopeOp_in_scope_642);
            scopeOp(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulescope_Ex;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:183:5: ( statement | INDENT ( statement )+ DEDENT )
            {
                int alt14=2;
                switch ( LA(1) )
                {
                case CHARACTER:
                case EMARK:
                case GID:
                case INTEGER:
                case KW_BREAK:
                case KW_CONTINUE:
                case KW_FALSE:
                case KW_IF:
                case KW_ON:
                case KW_TRUE:
                case KW_WHILE:
                case LBRACE:
                case LPAREN:
                case MINUS:
                case NEWLINE:
                case PLUS:
                case STRING:
                case TILDE:
                case VALID_NAME:
                	{
                		alt14=1;
                	}
                    break;
                case INDENT:
                	{
                		alt14=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto rulescope_Ex;

                }

                switch (alt14)
                {
            	case 1:
            	    // Cortolang.g:184:9: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_scope_658);
            	        statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescope_Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:186:9: INDENT ( statement )+ DEDENT
            	    {
            	         MATCHT(INDENT, &FOLLOW_INDENT_in_scope_678);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescope_Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        // Cortolang.g:186:16: ( statement )+
            	        {
            	            int cnt13=0;

            	            for (;;)
            	            {
            	                int alt13=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case CHARACTER:
            	        	case EMARK:
            	        	case GID:
            	        	case INTEGER:
            	        	case KW_BREAK:
            	        	case KW_CONTINUE:
            	        	case KW_FALSE:
            	        	case KW_IF:
            	        	case KW_ON:
            	        	case KW_TRUE:
            	        	case KW_WHILE:
            	        	case LBRACE:
            	        	case LPAREN:
            	        	case MINUS:
            	        	case NEWLINE:
            	        	case PLUS:
            	        	case STRING:
            	        	case TILDE:
            	        	case VALID_NAME:
            	        		{
            	        			alt13=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt13)
            	        	{
            	        	    case 1:
            	        	        // Cortolang.g:186:16: statement
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_statement_in_scope_680);
            	        	            statement(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulescope_Ex;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return ;
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt13 >= 1 )
            	        		{
            	        		    goto loop13;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    return ;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulescope_Ex;
            	        	}
            	        	cnt13++;
            	            }
            	            loop13: ;	/* Jump to here if this rule does not match */
            	        }

            	         MATCHT(DEDENT, &FOLLOW_DEDENT_in_scope_683);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescope_Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulescope_Ex; /* Prevent compiler warnings */
    rulescope_Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end scope_ */

/**
 * $ANTLR start functionDeclaration
 * Cortolang.g:194:1: functionDeclaration : typeLabel VALID_NAME LPAREN functionArguments RPAREN ( NEWLINE | EQUAL conditionalExpression NEWLINE | block ) ;
 */
static void
functionDeclaration(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:195:5: ( typeLabel VALID_NAME LPAREN functionArguments RPAREN ( NEWLINE | EQUAL conditionalExpression NEWLINE | block ) )
        // Cortolang.g:196:5: typeLabel VALID_NAME LPAREN functionArguments RPAREN ( NEWLINE | EQUAL conditionalExpression NEWLINE | block )
        {
            FOLLOWPUSH(FOLLOW_typeLabel_in_functionDeclaration714);
            typeLabel(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_functionDeclaration716);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(LPAREN, &FOLLOW_LPAREN_in_functionDeclaration718);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_functionArguments_in_functionDeclaration720);
            functionArguments(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(RPAREN, &FOLLOW_RPAREN_in_functionDeclaration722);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:197:5: ( NEWLINE | EQUAL conditionalExpression NEWLINE | block )
            {
                int alt15=3;
                switch ( LA(1) )
                {
                case NEWLINE:
                	{
                		alt15=1;
                	}
                    break;
                case EQUAL:
                	{
                		alt15=2;
                	}
                    break;
                case COLON:
                	{
                		alt15=3;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 15;
                    EXCEPTION->state        = 0;


                    goto rulefunctionDeclarationEx;

                }

                switch (alt15)
                {
            	case 1:
            	    // Cortolang.g:198:9: NEWLINE
            	    {
            	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_functionDeclaration738);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:200:9: EQUAL conditionalExpression NEWLINE
            	    {
            	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_functionDeclaration758);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_conditionalExpression_in_functionDeclaration760);
            	        conditionalExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_functionDeclaration762);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // Cortolang.g:202:9: block
            	    {
            	        FOLLOWPUSH(FOLLOW_block_in_functionDeclaration782);
            	        block(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start functionArguments
 * Cortolang.g:206:1: functionArguments : ( functionArgument ( COMMA functionArgument )* )? ;
 */
static void
functionArguments(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:207:5: ( ( functionArgument ( COMMA functionArgument )* )? )
        // Cortolang.g:208:5: ( functionArgument ( COMMA functionArgument )* )?
        {
            // Cortolang.g:208:5: ( functionArgument ( COMMA functionArgument )* )?
            {
                int alt17=2;
                switch ( LA(1) )
                {
                    case GID:
                    case VALID_NAME:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // Cortolang.g:208:7: functionArgument ( COMMA functionArgument )*
            	    {
            	        FOLLOWPUSH(FOLLOW_functionArgument_in_functionArguments811);
            	        functionArgument(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionArgumentsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        // Cortolang.g:208:24: ( COMMA functionArgument )*

            	        for (;;)
            	        {
            	            int alt16=2;
            	            switch ( LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt16=1;
            	            	}
            	                break;

            	            }

            	            switch (alt16)
            	            {
            	        	case 1:
            	        	    // Cortolang.g:208:26: COMMA functionArgument
            	        	    {
            	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_functionArguments815);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefunctionArgumentsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_functionArgument_in_functionArguments817);
            	        	        functionArgument(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefunctionArgumentsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop16;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop16: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionArgumentsEx; /* Prevent compiler warnings */
    rulefunctionArgumentsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionArguments */

/**
 * $ANTLR start functionArgument
 * Cortolang.g:212:1: functionArgument : typeLabel VALID_NAME ;
 */
static void
functionArgument(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:213:5: ( typeLabel VALID_NAME )
        // Cortolang.g:214:5: typeLabel VALID_NAME
        {
            FOLLOWPUSH(FOLLOW_typeLabel_in_functionArgument850);
            typeLabel(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionArgumentEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_functionArgument852);
            if  (HASEXCEPTION())
            {
                goto rulefunctionArgumentEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionArgumentEx; /* Prevent compiler warnings */
    rulefunctionArgumentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionArgument */

/**
 * $ANTLR start ifStatement
 * Cortolang.g:222:1: ifStatement : KW_IF expression ( block ) ( ( KW_ELSE )=> ( elseStatement ) )? ;
 */
static void
ifStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:223:5: ( KW_IF expression ( block ) ( ( KW_ELSE )=> ( elseStatement ) )? )
        // Cortolang.g:224:5: KW_IF expression ( block ) ( ( KW_ELSE )=> ( elseStatement ) )?
        {
             MATCHT(KW_IF, &FOLLOW_KW_IF_in_ifStatement878);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_expression_in_ifStatement880);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:225:5: ( block )
            // Cortolang.g:226:9: block
            {
                FOLLOWPUSH(FOLLOW_block_in_ifStatement896);
                block(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleifStatementEx;
                }
                if (HASFAILED())
                {
                    return ;
                }


            }


            // Cortolang.g:228:5: ( ( KW_ELSE )=> ( elseStatement ) )?
            {
                int alt18=2;
                switch ( LA(1) )
                {
                    case KW_ELSE:
                    	{
                    		{
                    		    int LA18_1 = LA(2);
                    		    if ( (synpred4_Cortolang(ctx)))
                    		    {
                    		        alt18=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // Cortolang.g:229:9: ( KW_ELSE )=> ( elseStatement )
            	    {
            	        // Cortolang.g:230:9: ( elseStatement )
            	        // Cortolang.g:230:11: elseStatement
            	        {
            	            FOLLOWPUSH(FOLLOW_elseStatement_in_ifStatement936);
            	            elseStatement(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleifStatementEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start elseStatement
 * Cortolang.g:234:1: elseStatement : KW_ELSE block ;
 */
static void
elseStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:235:5: ( KW_ELSE block )
        // Cortolang.g:236:5: KW_ELSE block
        {
             MATCHT(KW_ELSE, &FOLLOW_KW_ELSE_in_elseStatement966);
            if  (HASEXCEPTION())
            {
                goto ruleelseStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_block_in_elseStatement968);
            block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleelseStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleelseStatementEx; /* Prevent compiler warnings */
    ruleelseStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end elseStatement */

/**
 * $ANTLR start whileStatement
 * Cortolang.g:239:1: whileStatement : KW_WHILE expression block ;
 */
static void
whileStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:240:5: ( KW_WHILE expression block )
        // Cortolang.g:241:5: KW_WHILE expression block
        {
             MATCHT(KW_WHILE, &FOLLOW_KW_WHILE_in_whileStatement989);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_expression_in_whileStatement991);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_block_in_whileStatement993);
            block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start breakStatement
 * Cortolang.g:244:1: breakStatement : KW_BREAK ;
 */
static void
breakStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:245:5: ( KW_BREAK )
        // Cortolang.g:246:5: KW_BREAK
        {
             MATCHT(KW_BREAK, &FOLLOW_KW_BREAK_in_breakStatement1014);
            if  (HASEXCEPTION())
            {
                goto rulebreakStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebreakStatementEx; /* Prevent compiler warnings */
    rulebreakStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end breakStatement */

/**
 * $ANTLR start continueStatement
 * Cortolang.g:249:1: continueStatement : KW_CONTINUE ;
 */
static void
continueStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:250:5: ( KW_CONTINUE )
        // Cortolang.g:251:5: KW_CONTINUE
        {
             MATCHT(KW_CONTINUE, &FOLLOW_KW_CONTINUE_in_continueStatement1035);
            if  (HASEXCEPTION())
            {
                goto rulecontinueStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecontinueStatementEx; /* Prevent compiler warnings */
    rulecontinueStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end continueStatement */

/**
 * $ANTLR start expression
 * Cortolang.g:260:1: expression returns [ parser_ExpressionNode ___ node ] : assignmentExpression ;
 */
static parser_ExpressionNode ___
expression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ assignmentExpression3;
    #undef	RETURN_TYPE_assignmentExpression3
    #define	RETURN_TYPE_assignmentExpression3 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:265:5: ( assignmentExpression )
        // Cortolang.g:266:5: assignmentExpression
        {
            FOLLOWPUSH(FOLLOW_assignmentExpression_in_expression1071);
            assignmentExpression3=assignmentExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }
            if (HASFAILED())
            {
                return node;
            }


            if ( BACKTRACKING==0 )
            {

                        node = assignmentExpression3
                ;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end expression */

/**
 * $ANTLR start assignmentExpression
 * Cortolang.g:273:1: assignmentExpression returns [ parser_ExpressionNode ___ node ] : (e1= simpleCommaExpression ) ( ( assignmentOp ) e2= simpleCommaExpression )? ;
 */
static parser_ExpressionNode ___
assignmentExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:278:5: ( (e1= simpleCommaExpression ) ( ( assignmentOp ) e2= simpleCommaExpression )? )
        // Cortolang.g:279:5: (e1= simpleCommaExpression ) ( ( assignmentOp ) e2= simpleCommaExpression )?
        {
            // Cortolang.g:279:5: (e1= simpleCommaExpression )
            // Cortolang.g:280:9: e1= simpleCommaExpression
            {
                FOLLOWPUSH(FOLLOW_simpleCommaExpression_in_assignmentExpression1120);
                e1=simpleCommaExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleassignmentExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:285:5: ( ( assignmentOp ) e2= simpleCommaExpression )?
            {
                int alt19=2;
                switch ( LA(1) )
                {
                    case DIV_EQUAL:
                    case EQUAL:
                    case MINUS_EQUAL:
                    case PLUS_EQUAL:
                    case TIMES_EQUAL:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19)
                {
            	case 1:
            	    // Cortolang.g:286:9: ( assignmentOp ) e2= simpleCommaExpression
            	    {
            	        // Cortolang.g:286:9: ( assignmentOp )
            	        // Cortolang.g:287:13: assignmentOp
            	        {
            	            FOLLOWPUSH(FOLLOW_assignmentOp_in_assignmentExpression1166);
            	            assignmentOp(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleassignmentExpressionEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return node;
            	            }


            	        }


            	        FOLLOWPUSH(FOLLOW_simpleCommaExpression_in_assignmentExpression1188);
            	        e2=simpleCommaExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleassignmentExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "assignmentOp", e2
            	            );
            	                        // parser_BinaryExpressionNode _node = parser_BinaryExpressionNodeCreate(
            	                        //     0, 0, node, "assignmentOp", e2

            	                        // );
            	                        // node = parser_ExpressionNode(_node);
            	                    
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignmentExpressionEx; /* Prevent compiler warnings */
    ruleassignmentExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end assignmentExpression */

/**
 * $ANTLR start simpleCommaExpression
 * Cortolang.g:301:1: simpleCommaExpression returns [ parser_ExpressionNode ___ node ] : (e1= conditionalExpression ) ( COMMA e2= conditionalExpression )* ( COMMA )? ;
 */
static parser_ExpressionNode ___
simpleCommaExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:306:5: ( (e1= conditionalExpression ) ( COMMA e2= conditionalExpression )* ( COMMA )? )
        // Cortolang.g:307:5: (e1= conditionalExpression ) ( COMMA e2= conditionalExpression )* ( COMMA )?
        {
            // Cortolang.g:307:5: (e1= conditionalExpression )
            // Cortolang.g:308:9: e1= conditionalExpression
            {
                FOLLOWPUSH(FOLLOW_conditionalExpression_in_simpleCommaExpression1248);
                e1=conditionalExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesimpleCommaExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:313:5: ( COMMA e2= conditionalExpression )*

            for (;;)
            {
                int alt20=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		switch ( LA(2) )
                		{
                		case CHARACTER:
                		case EMARK:
                		case GID:
                		case INTEGER:
                		case KW_FALSE:
                		case KW_TRUE:
                		case LBRACE:
                		case LPAREN:
                		case MINUS:
                		case PLUS:
                		case STRING:
                		case TILDE:
                		case VALID_NAME:
                			{
                				alt20=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt20)
                {
            	case 1:
            	    // Cortolang.g:314:9: COMMA e2= conditionalExpression
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_simpleCommaExpression1280);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimpleCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_conditionalExpression_in_simpleCommaExpression1292);
            	        e2=conditionalExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimpleCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        parser_CommaExpressionNode _node;
            	                        if (!corto_instanceof(parser_CommaExpressionNode_o, node)) {
            	                            _node = parser_CommaExpressionNodeCreate(
            	                                0, 0, corto_llNew()
            	                            );
            	                            corto_llAppend(_node->expressions, node);
            	                            node = parser_ExpressionNode(_node);
            	                        } else {
            	                            _node = parser_CommaExpressionNode(node);
            	                        }
            	                        corto_llAppend(_node->expressions, e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


            // Cortolang.g:330:5: ( COMMA )?
            {
                int alt21=2;
                switch ( LA(1) )
                {
                    case COMMA:
                    	{
                    		alt21=1;
                    	}
                        break;
                }

                switch (alt21)
                {
            	case 1:
            	    // Cortolang.g:330:5: COMMA
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_simpleCommaExpression1315);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimpleCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimpleCommaExpressionEx; /* Prevent compiler warnings */
    rulesimpleCommaExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end simpleCommaExpression */

/**
 * $ANTLR start fullCommaExpression
 * Cortolang.g:336:1: fullCommaExpression : commaExpressionElem ( COMMA commaExpressionElem )* ( COMMA )? ;
 */
static void
fullCommaExpression(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:337:5: ( commaExpressionElem ( COMMA commaExpressionElem )* ( COMMA )? )
        // Cortolang.g:338:5: commaExpressionElem ( COMMA commaExpressionElem )* ( COMMA )?
        {
            FOLLOWPUSH(FOLLOW_commaExpressionElem_in_fullCommaExpression1339);
            commaExpressionElem(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefullCommaExpressionEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:339:5: ( COMMA commaExpressionElem )*

            for (;;)
            {
                int alt22=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		switch ( LA(2) )
                		{
                		case CHARACTER:
                		case EMARK:
                		case GID:
                		case INTEGER:
                		case KW_FALSE:
                		case KW_TRUE:
                		case LBRACE:
                		case LPAREN:
                		case MINUS:
                		case PLUS:
                		case STRING:
                		case TILDE:
                		case VALID_NAME:
                			{
                				alt22=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt22)
                {
            	case 1:
            	    // Cortolang.g:339:7: COMMA commaExpressionElem
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_fullCommaExpression1347);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefullCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_commaExpressionElem_in_fullCommaExpression1349);
            	        commaExpressionElem(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefullCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop22;	/* break out of the loop */
            	    break;
                }
            }
            loop22: ; /* Jump out to here if this rule does not match */


            // Cortolang.g:340:5: ( COMMA )?
            {
                int alt23=2;
                switch ( LA(1) )
                {
                    case COMMA:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23)
                {
            	case 1:
            	    // Cortolang.g:340:5: COMMA
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_fullCommaExpression1358);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefullCommaExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulefullCommaExpressionEx; /* Prevent compiler warnings */
    rulefullCommaExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end fullCommaExpression */

/**
 * $ANTLR start commaExpressionElem
 * Cortolang.g:343:1: commaExpressionElem : conditionalExpression ( EQUAL conditionalExpression )? ;
 */
static void
commaExpressionElem(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:344:5: ( conditionalExpression ( EQUAL conditionalExpression )? )
        // Cortolang.g:345:5: conditionalExpression ( EQUAL conditionalExpression )?
        {
            FOLLOWPUSH(FOLLOW_conditionalExpression_in_commaExpressionElem1380);
            conditionalExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecommaExpressionElemEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:346:5: ( EQUAL conditionalExpression )?
            {
                int alt24=2;
                switch ( LA(1) )
                {
                    case EQUAL:
                    	{
                    		alt24=1;
                    	}
                        break;
                }

                switch (alt24)
                {
            	case 1:
            	    // Cortolang.g:346:7: EQUAL conditionalExpression
            	    {
            	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_commaExpressionElem1388);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommaExpressionElemEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_conditionalExpression_in_commaExpressionElem1390);
            	        conditionalExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommaExpressionElemEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecommaExpressionElemEx; /* Prevent compiler warnings */
    rulecommaExpressionElemEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end commaExpressionElem */

/**
 * $ANTLR start conditionalExpression
 * Cortolang.g:350:1: conditionalExpression returns [ parser_ExpressionNode ___ node ] : (e1= logicOrExpression ) ( QMARK e2= logicOrExpression COLON e3= logicOrExpression )? ;
 */
static parser_ExpressionNode ___
conditionalExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    parser_ExpressionNode ___ e3;
    #undef	RETURN_TYPE_e3
    #define	RETURN_TYPE_e3 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = parser_ExpressionNodeCreate(0, 0);

    {
        // Cortolang.g:355:5: ( (e1= logicOrExpression ) ( QMARK e2= logicOrExpression COLON e3= logicOrExpression )? )
        // Cortolang.g:356:5: (e1= logicOrExpression ) ( QMARK e2= logicOrExpression COLON e3= logicOrExpression )?
        {
            // Cortolang.g:356:5: (e1= logicOrExpression )
            // Cortolang.g:357:9: e1= logicOrExpression
            {
                FOLLOWPUSH(FOLLOW_logicOrExpression_in_conditionalExpression1436);
                e1=logicOrExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleconditionalExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:362:5: ( QMARK e2= logicOrExpression COLON e3= logicOrExpression )?
            {
                int alt25=2;
                switch ( LA(1) )
                {
                    case QMARK:
                    	{
                    		alt25=1;
                    	}
                        break;
                }

                switch (alt25)
                {
            	case 1:
            	    // Cortolang.g:363:9: QMARK e2= logicOrExpression COLON e3= logicOrExpression
            	    {
            	         MATCHT(QMARK, &FOLLOW_QMARK_in_conditionalExpression1468);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_logicOrExpression_in_conditionalExpression1480);
            	        e2=logicOrExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	         MATCHT(COLON, &FOLLOW_COLON_in_conditionalExpression1490);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_logicOrExpression_in_conditionalExpression1502);
            	        e3=logicOrExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        parser_ConditionalExpressionNode _node = parser_ConditionalExpressionNodeCreate(
            	                            0, 0, node, e2
            	            , e3

            	                        );
            	                        node = parser_ExpressionNode(_node);
            	                    
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconditionalExpressionEx; /* Prevent compiler warnings */
    ruleconditionalExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end conditionalExpression */

/**
 * $ANTLR start logicOrExpression
 * Cortolang.g:377:1: logicOrExpression returns [ parser_ExpressionNode ___ node ] : (e1= logicAndExpression ) ( KW_OR e2= logicAndExpression )* ;
 */
static parser_ExpressionNode ___
logicOrExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:382:5: ( (e1= logicAndExpression ) ( KW_OR e2= logicAndExpression )* )
        // Cortolang.g:383:5: (e1= logicAndExpression ) ( KW_OR e2= logicAndExpression )*
        {
            // Cortolang.g:383:5: (e1= logicAndExpression )
            // Cortolang.g:384:9: e1= logicAndExpression
            {
                FOLLOWPUSH(FOLLOW_logicAndExpression_in_logicOrExpression1562);
                e1=logicAndExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulelogicOrExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:389:5: ( KW_OR e2= logicAndExpression )*

            for (;;)
            {
                int alt26=2;
                switch ( LA(1) )
                {
                case KW_OR:
                	{
                		alt26=1;
                	}
                    break;

                }

                switch (alt26)
                {
            	case 1:
            	    // Cortolang.g:390:9: KW_OR e2= logicAndExpression
            	    {
            	         MATCHT(KW_OR, &FOLLOW_KW_OR_in_logicOrExpression1594);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogicOrExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_logicAndExpression_in_logicOrExpression1606);
            	        e2=logicAndExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogicOrExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "KW_OR", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop26;	/* break out of the loop */
            	    break;
                }
            }
            loop26: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelogicOrExpressionEx; /* Prevent compiler warnings */
    rulelogicOrExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end logicOrExpression */

/**
 * $ANTLR start logicAndExpression
 * Cortolang.g:399:1: logicAndExpression returns [ parser_ExpressionNode ___ node ] : (e1= equalityExpression ) ( KW_AND e2= equalityExpression )* ;
 */
static parser_ExpressionNode ___
logicAndExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:404:5: ( (e1= equalityExpression ) ( KW_AND e2= equalityExpression )* )
        // Cortolang.g:405:5: (e1= equalityExpression ) ( KW_AND e2= equalityExpression )*
        {
            // Cortolang.g:405:5: (e1= equalityExpression )
            // Cortolang.g:406:9: e1= equalityExpression
            {
                FOLLOWPUSH(FOLLOW_equalityExpression_in_logicAndExpression1666);
                e1=equalityExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulelogicAndExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:411:5: ( KW_AND e2= equalityExpression )*

            for (;;)
            {
                int alt27=2;
                switch ( LA(1) )
                {
                case KW_AND:
                	{
                		alt27=1;
                	}
                    break;

                }

                switch (alt27)
                {
            	case 1:
            	    // Cortolang.g:412:9: KW_AND e2= equalityExpression
            	    {
            	         MATCHT(KW_AND, &FOLLOW_KW_AND_in_logicAndExpression1698);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogicAndExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_equalityExpression_in_logicAndExpression1710);
            	        e2=equalityExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogicAndExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "KW_AND", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop27;	/* break out of the loop */
            	    break;
                }
            }
            loop27: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelogicAndExpressionEx; /* Prevent compiler warnings */
    rulelogicAndExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end logicAndExpression */

/**
 * $ANTLR start equalityExpression
 * Cortolang.g:420:1: equalityExpression returns [ parser_ExpressionNode ___ node ] : (e1= comparisonExpression ) ( eqOp e2= comparisonExpression )? ;
 */
static parser_ExpressionNode ___
equalityExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:425:5: ( (e1= comparisonExpression ) ( eqOp e2= comparisonExpression )? )
        // Cortolang.g:426:5: (e1= comparisonExpression ) ( eqOp e2= comparisonExpression )?
        {
            // Cortolang.g:426:5: (e1= comparisonExpression )
            // Cortolang.g:427:9: e1= comparisonExpression
            {
                FOLLOWPUSH(FOLLOW_comparisonExpression_in_equalityExpression1769);
                e1=comparisonExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleequalityExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:432:5: ( eqOp e2= comparisonExpression )?
            {
                int alt28=2;
                switch ( LA(1) )
                {
                    case EQUALS:
                    case NOT_EQUALS:
                    	{
                    		alt28=1;
                    	}
                        break;
                }

                switch (alt28)
                {
            	case 1:
            	    // Cortolang.g:433:9: eqOp e2= comparisonExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_eqOp_in_equalityExpression1801);
            	        eqOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequalityExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_comparisonExpression_in_equalityExpression1813);
            	        e2=comparisonExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequalityExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "eqOp", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleequalityExpressionEx; /* Prevent compiler warnings */
    ruleequalityExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end equalityExpression */

/**
 * $ANTLR start comparisonExpression
 * Cortolang.g:441:1: comparisonExpression returns [ parser_ExpressionNode ___ node ] : (e1= bitOrExpression ) ( comparisonOp e2= bitOrExpression )? ;
 */
static parser_ExpressionNode ___
comparisonExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:446:5: ( (e1= bitOrExpression ) ( comparisonOp e2= bitOrExpression )? )
        // Cortolang.g:447:5: (e1= bitOrExpression ) ( comparisonOp e2= bitOrExpression )?
        {
            // Cortolang.g:447:5: (e1= bitOrExpression )
            // Cortolang.g:448:9: e1= bitOrExpression
            {
                FOLLOWPUSH(FOLLOW_bitOrExpression_in_comparisonExpression1872);
                e1=bitOrExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulecomparisonExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:453:5: ( comparisonOp e2= bitOrExpression )?
            {
                int alt29=2;
                switch ( LA(1) )
                {
                    case GREATER_THAN:
                    case GREATER_THAN_EQUAL:
                    case LESS_THAN:
                    case LESS_THAN_EQUAL:
                    	{
                    		alt29=1;
                    	}
                        break;
                }

                switch (alt29)
                {
            	case 1:
            	    // Cortolang.g:454:9: comparisonOp e2= bitOrExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_comparisonOp_in_comparisonExpression1904);
            	        comparisonOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomparisonExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_bitOrExpression_in_comparisonExpression1916);
            	        e2=bitOrExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomparisonExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "comparisonOp", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecomparisonExpressionEx; /* Prevent compiler warnings */
    rulecomparisonExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end comparisonExpression */

/**
 * $ANTLR start bitOrExpression
 * Cortolang.g:462:1: bitOrExpression returns [ parser_ExpressionNode ___ node ] : (e1= bitXorExpression ) ( PIPE e2= bitXorExpression )* ;
 */
static parser_ExpressionNode ___
bitOrExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:467:5: ( (e1= bitXorExpression ) ( PIPE e2= bitXorExpression )* )
        // Cortolang.g:468:5: (e1= bitXorExpression ) ( PIPE e2= bitXorExpression )*
        {
            // Cortolang.g:468:5: (e1= bitXorExpression )
            // Cortolang.g:469:9: e1= bitXorExpression
            {
                FOLLOWPUSH(FOLLOW_bitXorExpression_in_bitOrExpression1975);
                e1=bitXorExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulebitOrExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:474:5: ( PIPE e2= bitXorExpression )*

            for (;;)
            {
                int alt30=2;
                switch ( LA(1) )
                {
                case PIPE:
                	{
                		alt30=1;
                	}
                    break;

                }

                switch (alt30)
                {
            	case 1:
            	    // Cortolang.g:475:9: PIPE e2= bitXorExpression
            	    {
            	         MATCHT(PIPE, &FOLLOW_PIPE_in_bitOrExpression2007);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitOrExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_bitXorExpression_in_bitOrExpression2019);
            	        e2=bitXorExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitOrExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "PIPE", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop30;	/* break out of the loop */
            	    break;
                }
            }
            loop30: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebitOrExpressionEx; /* Prevent compiler warnings */
    rulebitOrExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end bitOrExpression */

/**
 * $ANTLR start bitXorExpression
 * Cortolang.g:483:1: bitXorExpression returns [ parser_ExpressionNode ___ node ] : (e1= bitAndExpression ) ( CIRCUMFLEX e2= bitAndExpression )* ;
 */
static parser_ExpressionNode ___
bitXorExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:488:5: ( (e1= bitAndExpression ) ( CIRCUMFLEX e2= bitAndExpression )* )
        // Cortolang.g:489:5: (e1= bitAndExpression ) ( CIRCUMFLEX e2= bitAndExpression )*
        {
            // Cortolang.g:489:5: (e1= bitAndExpression )
            // Cortolang.g:490:9: e1= bitAndExpression
            {
                FOLLOWPUSH(FOLLOW_bitAndExpression_in_bitXorExpression2078);
                e1=bitAndExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulebitXorExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:495:5: ( CIRCUMFLEX e2= bitAndExpression )*

            for (;;)
            {
                int alt31=2;
                switch ( LA(1) )
                {
                case CIRCUMFLEX:
                	{
                		alt31=1;
                	}
                    break;

                }

                switch (alt31)
                {
            	case 1:
            	    // Cortolang.g:496:9: CIRCUMFLEX e2= bitAndExpression
            	    {
            	         MATCHT(CIRCUMFLEX, &FOLLOW_CIRCUMFLEX_in_bitXorExpression2110);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitXorExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_bitAndExpression_in_bitXorExpression2122);
            	        e2=bitAndExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitXorExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "CIRCUMFLEX", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop31;	/* break out of the loop */
            	    break;
                }
            }
            loop31: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebitXorExpressionEx; /* Prevent compiler warnings */
    rulebitXorExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end bitXorExpression */

/**
 * $ANTLR start bitAndExpression
 * Cortolang.g:504:1: bitAndExpression returns [ parser_ExpressionNode ___ node ] : (e1= shiftExpression ) ( AMPERSAND e2= shiftExpression )* ;
 */
static parser_ExpressionNode ___
bitAndExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:509:5: ( (e1= shiftExpression ) ( AMPERSAND e2= shiftExpression )* )
        // Cortolang.g:510:5: (e1= shiftExpression ) ( AMPERSAND e2= shiftExpression )*
        {
            // Cortolang.g:510:5: (e1= shiftExpression )
            // Cortolang.g:511:9: e1= shiftExpression
            {
                FOLLOWPUSH(FOLLOW_shiftExpression_in_bitAndExpression2181);
                e1=shiftExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulebitAndExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:516:5: ( AMPERSAND e2= shiftExpression )*

            for (;;)
            {
                int alt32=2;
                switch ( LA(1) )
                {
                case AMPERSAND:
                	{
                		alt32=1;
                	}
                    break;

                }

                switch (alt32)
                {
            	case 1:
            	    // Cortolang.g:517:9: AMPERSAND e2= shiftExpression
            	    {
            	         MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_bitAndExpression2213);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitAndExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_shiftExpression_in_bitAndExpression2225);
            	        e2=shiftExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitAndExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "AMPERSAND", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop32;	/* break out of the loop */
            	    break;
                }
            }
            loop32: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebitAndExpressionEx; /* Prevent compiler warnings */
    rulebitAndExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end bitAndExpression */

/**
 * $ANTLR start shiftExpression
 * Cortolang.g:525:1: shiftExpression returns [ parser_ExpressionNode ___ node ] : (e1= addExpression ) ( shiftOp e2= addExpression )* ;
 */
static parser_ExpressionNode ___
shiftExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:530:5: ( (e1= addExpression ) ( shiftOp e2= addExpression )* )
        // Cortolang.g:531:5: (e1= addExpression ) ( shiftOp e2= addExpression )*
        {
            // Cortolang.g:531:5: (e1= addExpression )
            // Cortolang.g:532:9: e1= addExpression
            {
                FOLLOWPUSH(FOLLOW_addExpression_in_shiftExpression2284);
                e1=addExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleshiftExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:537:5: ( shiftOp e2= addExpression )*

            for (;;)
            {
                int alt33=2;
                switch ( LA(1) )
                {
                case LSHIFT:
                case RSHIFT:
                	{
                		alt33=1;
                	}
                    break;

                }

                switch (alt33)
                {
            	case 1:
            	    // Cortolang.g:538:9: shiftOp e2= addExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_shiftOp_in_shiftExpression2316);
            	        shiftOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleshiftExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_addExpression_in_shiftExpression2328);
            	        e2=addExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleshiftExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "shiftOp", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop33;	/* break out of the loop */
            	    break;
                }
            }
            loop33: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleshiftExpressionEx; /* Prevent compiler warnings */
    ruleshiftExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end shiftExpression */

/**
 * $ANTLR start addExpression
 * Cortolang.g:546:1: addExpression returns [ parser_ExpressionNode ___ node ] : (e1= multExpression ) ( ( addOp multExpression )=> addOp e2= multExpression )* ;
 */
static parser_ExpressionNode ___
addExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = parser_ExpressionNodeCreate(0, 0);

    {
        // Cortolang.g:551:5: ( (e1= multExpression ) ( ( addOp multExpression )=> addOp e2= multExpression )* )
        // Cortolang.g:552:5: (e1= multExpression ) ( ( addOp multExpression )=> addOp e2= multExpression )*
        {
            // Cortolang.g:552:5: (e1= multExpression )
            // Cortolang.g:553:9: e1= multExpression
            {
                FOLLOWPUSH(FOLLOW_multExpression_in_addExpression2387);
                e1=multExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleaddExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:558:5: ( ( addOp multExpression )=> addOp e2= multExpression )*

            for (;;)
            {
                int alt34=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA34_0 = LA(1);
                    if ( (synpred5_Cortolang(ctx)) && (LA34_0 == MINUS || LA34_0 == PLUS))
                    {
                        alt34=1;
                    }

                }
                switch (alt34)
                {
            	case 1:
            	    // Cortolang.g:559:9: ( addOp multExpression )=> addOp e2= multExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_addOp_in_addExpression2435);
            	        addOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_multExpression_in_addExpression2447);
            	        e2=multExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "addOp", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop34;	/* break out of the loop */
            	    break;
                }
            }
            loop34: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddExpressionEx; /* Prevent compiler warnings */
    ruleaddExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end addExpression */

/**
 * $ANTLR start multExpression
 * Cortolang.g:568:1: multExpression returns [ parser_ExpressionNode ___ node ] : (e1= unaryExpression ) ( multOp e2= unaryExpression )* ;
 */
static parser_ExpressionNode ___
multExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    parser_ExpressionNode ___ e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 parser_ExpressionNode ___

    parser_ExpressionNode ___ e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 parser_ExpressionNode ___

    /* Initialize rule variables
     */


        node = NULL;

    {
        // Cortolang.g:573:5: ( (e1= unaryExpression ) ( multOp e2= unaryExpression )* )
        // Cortolang.g:574:5: (e1= unaryExpression ) ( multOp e2= unaryExpression )*
        {
            // Cortolang.g:574:5: (e1= unaryExpression )
            // Cortolang.g:575:9: e1= unaryExpression
            {
                FOLLOWPUSH(FOLLOW_unaryExpression_in_multExpression2506);
                e1=unaryExpression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulemultExpressionEx;
                }
                if (HASFAILED())
                {
                    return node;
                }


                if ( BACKTRACKING==0 )
                {

                                node = e1
                    ;
                            
                }


            }


            // Cortolang.g:580:5: ( multOp e2= unaryExpression )*

            for (;;)
            {
                int alt35=2;
                switch ( LA(1) )
                {
                case ASTERISK:
                case SLASH:
                	{
                		alt35=1;
                	}
                    break;

                }

                switch (alt35)
                {
            	case 1:
            	    // Cortolang.g:581:9: multOp e2= unaryExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_multOp_in_multExpression2538);
            	        multOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        FOLLOWPUSH(FOLLOW_unaryExpression_in_multExpression2550);
            	        e2=unaryExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {

            	                        node = parser_createBinaryExpression(e1
            	            , "multOp", e2
            	            );
            	                    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop35;	/* break out of the loop */
            	    break;
                }
            }
            loop35: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultExpressionEx; /* Prevent compiler warnings */
    rulemultExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end multExpression */

/**
 * $ANTLR start unaryExpression
 * Cortolang.g:589:1: unaryExpression returns [ parser_ExpressionNode ___ node ] : ( unaryOp )? postfixExpression ;
 */
static parser_ExpressionNode ___
unaryExpression(pCortolangParser ctx)
{
    parser_ExpressionNode ___ node;


    /* Initialize rule variables
     */


        node = parser_ExpressionNodeCreate(0, 0);

    {
        // Cortolang.g:594:5: ( ( unaryOp )? postfixExpression )
        // Cortolang.g:595:5: ( unaryOp )? postfixExpression
        {
            // Cortolang.g:595:5: ( unaryOp )?
            {
                int alt36=2;
                switch ( LA(1) )
                {
                    case EMARK:
                    case MINUS:
                    case PLUS:
                    case TILDE:
                    	{
                    		alt36=1;
                    	}
                        break;
                }

                switch (alt36)
                {
            	case 1:
            	    // Cortolang.g:595:5: unaryOp
            	    {
            	        FOLLOWPUSH(FOLLOW_unaryOp_in_unaryExpression2597);
            	        unaryOp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunaryExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return node;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_postfixExpression_in_unaryExpression2600);
            postfixExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleunaryExpressionEx;
            }
            if (HASFAILED())
            {
                return node;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunaryExpressionEx; /* Prevent compiler warnings */
    ruleunaryExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return node;
}
/* $ANTLR end unaryExpression */

/**
 * $ANTLR start postfixExpression
 * Cortolang.g:598:1: postfixExpression : atomExpression ( postfixOperation )* ;
 */
static void
postfixExpression(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:599:5: ( atomExpression ( postfixOperation )* )
        // Cortolang.g:600:5: atomExpression ( postfixOperation )*
        {
            FOLLOWPUSH(FOLLOW_atomExpression_in_postfixExpression2621);
            atomExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepostfixExpressionEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:600:20: ( postfixOperation )*

            for (;;)
            {
                int alt37=2;
                switch ( LA(1) )
                {
                case DOT:
                case LBRACK:
                case LPAREN:
                	{
                		alt37=1;
                	}
                    break;

                }

                switch (alt37)
                {
            	case 1:
            	    // Cortolang.g:600:20: postfixOperation
            	    {
            	        FOLLOWPUSH(FOLLOW_postfixOperation_in_postfixExpression2623);
            	        postfixOperation(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfixExpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepostfixExpressionEx; /* Prevent compiler warnings */
    rulepostfixExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end postfixExpression */

/**
 * $ANTLR start atomExpression
 * Cortolang.g:603:1: atomExpression : ( literal | identifier | LPAREN expression RPAREN | anonymousObject );
 */
static void
atomExpression(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:604:5: ( literal | identifier | LPAREN expression RPAREN | anonymousObject )

            ANTLR3_UINT32 alt38;

            alt38=4;

            switch ( LA(1) )
            {
            case CHARACTER:
            case INTEGER:
            case KW_FALSE:
            case KW_TRUE:
            case STRING:
            	{
            		alt38=1;
            	}
                break;
            case GID:
            case VALID_NAME:
            	{
            		alt38=2;
            	}
                break;
            case LPAREN:
            	{
            		alt38=3;
            	}
                break;
            case LBRACE:
            	{
            		alt38=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 38;
                EXCEPTION->state        = 0;


                goto ruleatomExpressionEx;

            }

            switch (alt38)
            {
        	case 1:
        	    // Cortolang.g:605:5: literal
        	    {
        	        FOLLOWPUSH(FOLLOW_literal_in_atomExpression2645);
        	        literal(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:607:5: identifier
        	    {
        	        FOLLOWPUSH(FOLLOW_identifier_in_atomExpression2657);
        	        identifier(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:609:5: LPAREN expression RPAREN
        	    {
        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_atomExpression2669);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_atomExpression2671);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_atomExpression2673);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:611:5: anonymousObject
        	    {
        	        FOLLOWPUSH(FOLLOW_anonymousObject_in_atomExpression2685);
        	        anonymousObject(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomExpressionEx; /* Prevent compiler warnings */
    ruleatomExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end atomExpression */

/**
 * $ANTLR start anonymousObject
 * Cortolang.g:614:1: anonymousObject : LBRACE ( fullCommaExpression )? RBRACE ;
 */
static void
anonymousObject(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:615:5: ( LBRACE ( fullCommaExpression )? RBRACE )
        // Cortolang.g:616:5: LBRACE ( fullCommaExpression )? RBRACE
        {
             MATCHT(LBRACE, &FOLLOW_LBRACE_in_anonymousObject2706);
            if  (HASEXCEPTION())
            {
                goto ruleanonymousObjectEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:616:12: ( fullCommaExpression )?
            {
                int alt39=2;
                switch ( LA(1) )
                {
                    case CHARACTER:
                    case EMARK:
                    case GID:
                    case INTEGER:
                    case KW_FALSE:
                    case KW_TRUE:
                    case LBRACE:
                    case LPAREN:
                    case MINUS:
                    case PLUS:
                    case STRING:
                    case TILDE:
                    case VALID_NAME:
                    	{
                    		alt39=1;
                    	}
                        break;
                }

                switch (alt39)
                {
            	case 1:
            	    // Cortolang.g:616:12: fullCommaExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_fullCommaExpression_in_anonymousObject2708);
            	        fullCommaExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleanonymousObjectEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(RBRACE, &FOLLOW_RBRACE_in_anonymousObject2711);
            if  (HASEXCEPTION())
            {
                goto ruleanonymousObjectEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleanonymousObjectEx; /* Prevent compiler warnings */
    ruleanonymousObjectEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end anonymousObject */

/**
 * $ANTLR start observerStatement
 * Cortolang.g:623:1: observerStatement : KW_ON eventMask expression ( block | NEWLINE ) ;
 */
static void
observerStatement(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:624:5: ( KW_ON eventMask expression ( block | NEWLINE ) )
        // Cortolang.g:625:5: KW_ON eventMask expression ( block | NEWLINE )
        {
             MATCHT(KW_ON, &FOLLOW_KW_ON_in_observerStatement2736);
            if  (HASEXCEPTION())
            {
                goto ruleobserverStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_eventMask_in_observerStatement2738);
            eventMask(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobserverStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_expression_in_observerStatement2740);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobserverStatementEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:625:32: ( block | NEWLINE )
            {
                int alt40=2;
                switch ( LA(1) )
                {
                case COLON:
                	{
                		alt40=1;
                	}
                    break;
                case NEWLINE:
                	{
                		alt40=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 40;
                    EXCEPTION->state        = 0;


                    goto ruleobserverStatementEx;

                }

                switch (alt40)
                {
            	case 1:
            	    // Cortolang.g:625:34: block
            	    {
            	        FOLLOWPUSH(FOLLOW_block_in_observerStatement2744);
            	        block(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobserverStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Cortolang.g:625:42: NEWLINE
            	    {
            	         MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_observerStatement2748);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobserverStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleobserverStatementEx; /* Prevent compiler warnings */
    ruleobserverStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end observerStatement */

/**
 * $ANTLR start eventMask
 * Cortolang.g:628:1: eventMask : eventFlag ( PIPE eventFlag )* ;
 */
static void
eventMask(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:629:5: ( eventFlag ( PIPE eventFlag )* )
        // Cortolang.g:630:5: eventFlag ( PIPE eventFlag )*
        {
            FOLLOWPUSH(FOLLOW_eventFlag_in_eventMask2771);
            eventFlag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleeventMaskEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:630:15: ( PIPE eventFlag )*

            for (;;)
            {
                int alt41=2;
                switch ( LA(1) )
                {
                case PIPE:
                	{
                		alt41=1;
                	}
                    break;

                }

                switch (alt41)
                {
            	case 1:
            	    // Cortolang.g:630:17: PIPE eventFlag
            	    {
            	         MATCHT(PIPE, &FOLLOW_PIPE_in_eventMask2775);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleeventMaskEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_eventFlag_in_eventMask2777);
            	        eventFlag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleeventMaskEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop41;	/* break out of the loop */
            	    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleeventMaskEx; /* Prevent compiler warnings */
    ruleeventMaskEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eventMask */

/**
 * $ANTLR start eventFlag
 * Cortolang.g:633:1: eventFlag : ( eventBaseFlag | eventScopeFlag );
 */
static void
eventFlag(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:633:11: ( eventBaseFlag | eventScopeFlag )

            ANTLR3_UINT32 alt42;

            alt42=2;

            switch ( LA(1) )
            {
            case KW_DECLARE:
            case KW_DEFINE:
            case KW_DESTRUCT:
            case KW_UPDATE:
            	{
            		alt42=1;
            	}
                break;
            case KW_SCOPE:
            case KW_SELF:
            case KW_SYNCHRONIZED:
            case KW_TREE:
            	{
            		alt42=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 42;
                EXCEPTION->state        = 0;


                goto ruleeventFlagEx;

            }

            switch (alt42)
            {
        	case 1:
        	    // Cortolang.g:633:13: eventBaseFlag
        	    {
        	        FOLLOWPUSH(FOLLOW_eventBaseFlag_in_eventFlag2793);
        	        eventBaseFlag(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleeventFlagEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:633:29: eventScopeFlag
        	    {
        	        FOLLOWPUSH(FOLLOW_eventScopeFlag_in_eventFlag2797);
        	        eventScopeFlag(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleeventFlagEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleeventFlagEx; /* Prevent compiler warnings */
    ruleeventFlagEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eventFlag */

/**
 * $ANTLR start eventBaseFlag
 * Cortolang.g:637:1: eventBaseFlag : ( KW_DECLARE | KW_DEFINE | KW_UPDATE | KW_DESTRUCT );
 */
static void
eventBaseFlag(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:637:15: ( KW_DECLARE | KW_DEFINE | KW_UPDATE | KW_DESTRUCT )
        // Cortolang.g:
        {
            if ( ((LA(1) >= KW_DECLARE) && (LA(1) <= KW_DESTRUCT)) || LA(1) == KW_UPDATE )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleeventBaseFlagEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleeventBaseFlagEx; /* Prevent compiler warnings */
    ruleeventBaseFlagEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eventBaseFlag */

/**
 * $ANTLR start eventScopeFlag
 * Cortolang.g:639:1: eventScopeFlag : ( KW_SELF | KW_SCOPE | KW_TREE | KW_SYNCHRONIZED );
 */
static void
eventScopeFlag(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:639:16: ( KW_SELF | KW_SCOPE | KW_TREE | KW_SYNCHRONIZED )
        // Cortolang.g:
        {
            if ( ((LA(1) >= KW_SCOPE) && (LA(1) <= KW_TREE)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleeventScopeFlagEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleeventScopeFlagEx; /* Prevent compiler warnings */
    ruleeventScopeFlagEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eventScopeFlag */

/**
 * $ANTLR start assignmentOp
 * Cortolang.g:645:1: assignmentOp : ( EQUAL | PLUS_EQUAL | MINUS_EQUAL | TIMES_EQUAL | DIV_EQUAL );
 */
static void
assignmentOp(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:646:5: ( EQUAL | PLUS_EQUAL | MINUS_EQUAL | TIMES_EQUAL | DIV_EQUAL )
        // Cortolang.g:
        {
            if ( LA(1) == DIV_EQUAL || LA(1) == EQUAL || LA(1) == MINUS_EQUAL || LA(1) == PLUS_EQUAL || LA(1) == TIMES_EQUAL )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleassignmentOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignmentOpEx; /* Prevent compiler warnings */
    ruleassignmentOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end assignmentOp */

/**
 * $ANTLR start eqOp
 * Cortolang.g:652:1: eqOp : ( EQUALS | NOT_EQUALS );
 */
static void
eqOp(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:652:6: ( EQUALS | NOT_EQUALS )
        // Cortolang.g:
        {
            if ( LA(1) == EQUALS || LA(1) == NOT_EQUALS )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleeqOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleeqOpEx; /* Prevent compiler warnings */
    ruleeqOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end eqOp */

/**
 * $ANTLR start comparisonOp
 * Cortolang.g:658:1: comparisonOp : ( GREATER_THAN | LESS_THAN | GREATER_THAN_EQUAL | LESS_THAN_EQUAL );
 */
static void
comparisonOp(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:658:13: ( GREATER_THAN | LESS_THAN | GREATER_THAN_EQUAL | LESS_THAN_EQUAL )
        // Cortolang.g:
        {
            if ( ((LA(1) >= GREATER_THAN) && (LA(1) <= GREATER_THAN_EQUAL)) || ((LA(1) >= LESS_THAN) && (LA(1) <= LESS_THAN_EQUAL)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulecomparisonOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecomparisonOpEx; /* Prevent compiler warnings */
    rulecomparisonOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end comparisonOp */

/**
 * $ANTLR start shiftOp
 * Cortolang.g:662:1: shiftOp : ( LSHIFT | RSHIFT );
 */
static void
shiftOp(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:663:5: ( LSHIFT | RSHIFT )
        // Cortolang.g:
        {
            if ( LA(1) == LSHIFT || LA(1) == RSHIFT )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleshiftOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleshiftOpEx; /* Prevent compiler warnings */
    ruleshiftOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end shiftOp */

/**
 * $ANTLR start addOp
 * Cortolang.g:669:1: addOp : ( PLUS | MINUS );
 */
static void
addOp(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:670:5: ( PLUS | MINUS )
        // Cortolang.g:
        {
            if ( LA(1) == MINUS || LA(1) == PLUS )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleaddOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddOpEx; /* Prevent compiler warnings */
    ruleaddOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end addOp */

/**
 * $ANTLR start multOp
 * Cortolang.g:676:1: multOp : ( ASTERISK | SLASH );
 */
static void
multOp(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:677:5: ( ASTERISK | SLASH )
        // Cortolang.g:
        {
            if ( LA(1) == ASTERISK || LA(1) == SLASH )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulemultOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultOpEx; /* Prevent compiler warnings */
    rulemultOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end multOp */

/**
 * $ANTLR start unaryOp
 * Cortolang.g:683:1: unaryOp : ( TILDE | MINUS | PLUS | EMARK );
 */
static void
unaryOp(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:684:5: ( TILDE | MINUS | PLUS | EMARK )
        // Cortolang.g:
        {
            if ( LA(1) == EMARK || LA(1) == MINUS || LA(1) == PLUS || LA(1) == TILDE )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleunaryOpEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunaryOpEx; /* Prevent compiler warnings */
    ruleunaryOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end unaryOp */

/**
 * $ANTLR start postfixOperation
 * Cortolang.g:694:1: postfixOperation : ( functionCall | memberAccess | elementAccess );
 */
static void
postfixOperation(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:695:5: ( functionCall | memberAccess | elementAccess )

            ANTLR3_UINT32 alt43;

            alt43=3;

            switch ( LA(1) )
            {
            case LPAREN:
            	{
            		alt43=1;
            	}
                break;
            case DOT:
            	{
            		alt43=2;
            	}
                break;
            case LBRACK:
            	{
            		alt43=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 43;
                EXCEPTION->state        = 0;


                goto rulepostfixOperationEx;

            }

            switch (alt43)
            {
        	case 1:
        	    // Cortolang.g:696:5: functionCall
        	    {
        	        FOLLOWPUSH(FOLLOW_functionCall_in_postfixOperation3121);
        	        functionCall(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostfixOperationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:698:5: memberAccess
        	    {
        	        FOLLOWPUSH(FOLLOW_memberAccess_in_postfixOperation3133);
        	        memberAccess(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostfixOperationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:700:5: elementAccess
        	    {
        	        FOLLOWPUSH(FOLLOW_elementAccess_in_postfixOperation3145);
        	        elementAccess(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostfixOperationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulepostfixOperationEx; /* Prevent compiler warnings */
    rulepostfixOperationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end postfixOperation */

/**
 * $ANTLR start functionCall
 * Cortolang.g:703:1: functionCall : LPAREN ( fullCommaExpression )? RPAREN ;
 */
static void
functionCall(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:704:5: ( LPAREN ( fullCommaExpression )? RPAREN )
        // Cortolang.g:705:5: LPAREN ( fullCommaExpression )? RPAREN
        {
             MATCHT(LPAREN, &FOLLOW_LPAREN_in_functionCall3166);
            if  (HASEXCEPTION())
            {
                goto rulefunctionCallEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:705:12: ( fullCommaExpression )?
            {
                int alt44=2;
                switch ( LA(1) )
                {
                    case CHARACTER:
                    case EMARK:
                    case GID:
                    case INTEGER:
                    case KW_FALSE:
                    case KW_TRUE:
                    case LBRACE:
                    case LPAREN:
                    case MINUS:
                    case PLUS:
                    case STRING:
                    case TILDE:
                    case VALID_NAME:
                    	{
                    		alt44=1;
                    	}
                        break;
                }

                switch (alt44)
                {
            	case 1:
            	    // Cortolang.g:705:12: fullCommaExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_fullCommaExpression_in_functionCall3168);
            	        fullCommaExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionCallEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(RPAREN, &FOLLOW_RPAREN_in_functionCall3171);
            if  (HASEXCEPTION())
            {
                goto rulefunctionCallEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionCallEx; /* Prevent compiler warnings */
    rulefunctionCallEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionCall */

/**
 * $ANTLR start memberAccess
 * Cortolang.g:708:1: memberAccess : DOT VALID_NAME ;
 */
static void
memberAccess(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:709:5: ( DOT VALID_NAME )
        // Cortolang.g:710:5: DOT VALID_NAME
        {
             MATCHT(DOT, &FOLLOW_DOT_in_memberAccess3192);
            if  (HASEXCEPTION())
            {
                goto rulememberAccessEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_memberAccess3194);
            if  (HASEXCEPTION())
            {
                goto rulememberAccessEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulememberAccessEx; /* Prevent compiler warnings */
    rulememberAccessEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end memberAccess */

/**
 * $ANTLR start elementAccess
 * Cortolang.g:713:1: elementAccess : LBRACK ( fullCommaExpression )? RBRACK ;
 */
static void
elementAccess(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:714:5: ( LBRACK ( fullCommaExpression )? RBRACK )
        // Cortolang.g:715:5: LBRACK ( fullCommaExpression )? RBRACK
        {
             MATCHT(LBRACK, &FOLLOW_LBRACK_in_elementAccess3215);
            if  (HASEXCEPTION())
            {
                goto ruleelementAccessEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:715:12: ( fullCommaExpression )?
            {
                int alt45=2;
                switch ( LA(1) )
                {
                    case CHARACTER:
                    case EMARK:
                    case GID:
                    case INTEGER:
                    case KW_FALSE:
                    case KW_TRUE:
                    case LBRACE:
                    case LPAREN:
                    case MINUS:
                    case PLUS:
                    case STRING:
                    case TILDE:
                    case VALID_NAME:
                    	{
                    		alt45=1;
                    	}
                        break;
                }

                switch (alt45)
                {
            	case 1:
            	    // Cortolang.g:715:12: fullCommaExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_fullCommaExpression_in_elementAccess3217);
            	        fullCommaExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleelementAccessEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(RBRACK, &FOLLOW_RBRACK_in_elementAccess3220);
            if  (HASEXCEPTION())
            {
                goto ruleelementAccessEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleelementAccessEx; /* Prevent compiler warnings */
    ruleelementAccessEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end elementAccess */

/**
 * $ANTLR start postScopeOperator
 * Cortolang.g:718:1: postScopeOperator : DOUBLE_COLON ;
 */
static void
postScopeOperator(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:718:19: ( DOUBLE_COLON )
        // Cortolang.g:718:21: DOUBLE_COLON
        {
             MATCHT(DOUBLE_COLON, &FOLLOW_DOUBLE_COLON_in_postScopeOperator3233);
            if  (HASEXCEPTION())
            {
                goto rulepostScopeOperatorEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepostScopeOperatorEx; /* Prevent compiler warnings */
    rulepostScopeOperatorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end postScopeOperator */

/**
 * $ANTLR start preScopeOperator
 * Cortolang.g:719:1: preScopeOperator : TRIPLE_COLON ;
 */
static void
preScopeOperator(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:719:18: ( TRIPLE_COLON )
        // Cortolang.g:719:20: TRIPLE_COLON
        {
             MATCHT(TRIPLE_COLON, &FOLLOW_TRIPLE_COLON_in_preScopeOperator3241);
            if  (HASEXCEPTION())
            {
                goto rulepreScopeOperatorEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepreScopeOperatorEx; /* Prevent compiler warnings */
    rulepreScopeOperatorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end preScopeOperator */

/**
 * $ANTLR start constant
 * Cortolang.g:725:1: constant : ( VALID_NAME | GID | literal );
 */
static void
constant(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:726:5: ( VALID_NAME | GID | literal )

            ANTLR3_UINT32 alt46;

            alt46=3;

            switch ( LA(1) )
            {
            case VALID_NAME:
            	{
            		alt46=1;
            	}
                break;
            case GID:
            	{
            		alt46=2;
            	}
                break;
            case CHARACTER:
            case INTEGER:
            case KW_FALSE:
            case KW_TRUE:
            case STRING:
            	{
            		alt46=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 46;
                EXCEPTION->state        = 0;


                goto ruleconstantEx;

            }

            switch (alt46)
            {
        	case 1:
        	    // Cortolang.g:727:5: VALID_NAME
        	    {
        	         MATCHT(VALID_NAME, &FOLLOW_VALID_NAME_in_constant3262);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:729:5: GID
        	    {
        	         MATCHT(GID, &FOLLOW_GID_in_constant3274);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:731:5: literal
        	    {
        	        FOLLOWPUSH(FOLLOW_literal_in_constant3286);
        	        literal(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end constant */

/**
 * $ANTLR start identifier
 * Cortolang.g:734:1: identifier : ( VALID_NAME | GID );
 */
static void
identifier(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:735:5: ( VALID_NAME | GID )
        // Cortolang.g:
        {
            if ( LA(1) == GID || LA(1) == VALID_NAME )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleidentifierEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end identifier */

/**
 * $ANTLR start typeLabel
 * Cortolang.g:741:1: typeLabel : identifier ( anonymousObject )* ;
 */
static void
typeLabel(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:742:5: ( identifier ( anonymousObject )* )
        // Cortolang.g:743:5: identifier ( anonymousObject )*
        {
            FOLLOWPUSH(FOLLOW_identifier_in_typeLabel3340);
            identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeLabelEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // Cortolang.g:743:16: ( anonymousObject )*

            for (;;)
            {
                int alt47=2;
                switch ( LA(1) )
                {
                case LBRACE:
                	{
                		alt47=1;
                	}
                    break;

                }

                switch (alt47)
                {
            	case 1:
            	    // Cortolang.g:743:16: anonymousObject
            	    {
            	        FOLLOWPUSH(FOLLOW_anonymousObject_in_typeLabel3342);
            	        anonymousObject(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeLabelEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop47;	/* break out of the loop */
            	    break;
                }
            }
            loop47: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletypeLabelEx; /* Prevent compiler warnings */
    ruletypeLabelEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end typeLabel */

/**
 * $ANTLR start literal
 * Cortolang.g:746:1: literal : ( booleanLiteral | CHARACTER | INTEGER | STRING );
 */
static void
literal(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  Cortolang.g:747:5: ( booleanLiteral | CHARACTER | INTEGER | STRING )

            ANTLR3_UINT32 alt48;

            alt48=4;

            switch ( LA(1) )
            {
            case KW_FALSE:
            case KW_TRUE:
            	{
            		alt48=1;
            	}
                break;
            case CHARACTER:
            	{
            		alt48=2;
            	}
                break;
            case INTEGER:
            	{
            		alt48=3;
            	}
                break;
            case STRING:
            	{
            		alt48=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 48;
                EXCEPTION->state        = 0;


                goto ruleliteralEx;

            }

            switch (alt48)
            {
        	case 1:
        	    // Cortolang.g:748:5: booleanLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_booleanLiteral_in_literal3364);
        	        booleanLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Cortolang.g:750:5: CHARACTER
        	    {
        	         MATCHT(CHARACTER, &FOLLOW_CHARACTER_in_literal3376);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Cortolang.g:752:5: INTEGER
        	    {
        	         MATCHT(INTEGER, &FOLLOW_INTEGER_in_literal3388);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Cortolang.g:754:5: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_literal3400);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end literal */

/**
 * $ANTLR start booleanLiteral
 * Cortolang.g:757:1: booleanLiteral : ( KW_TRUE | KW_FALSE );
 */
static void
booleanLiteral(pCortolangParser ctx)
{
    /* Initialize rule variables
     */

    {
        // Cortolang.g:758:5: ( KW_TRUE | KW_FALSE )
        // Cortolang.g:
        {
            if ( LA(1) == KW_FALSE || LA(1) == KW_TRUE )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulebooleanLiteralEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebooleanLiteralEx; /* Prevent compiler warnings */
    rulebooleanLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end booleanLiteral */

// $ANTLR start synpred1_Cortolang
static void synpred1_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:71:5: ( declarativeStatement )
    // Cortolang.g:71:6: declarativeStatement
    {
        FOLLOWPUSH(FOLLOW_declarativeStatement_in_synpred1_Cortolang183);
        declarativeStatement(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_CortolangEx; /* Prevent compiler warnings */
rulesynpred1_CortolangEx: ;

}
// $ANTLR end synpred1_Cortolang

// $ANTLR start synpred2_Cortolang
static void synpred2_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:87:5: ( functionDeclaration )
    // Cortolang.g:87:6: functionDeclaration
    {
        FOLLOWPUSH(FOLLOW_functionDeclaration_in_synpred2_Cortolang264);
        functionDeclaration(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_CortolangEx; /* Prevent compiler warnings */
rulesynpred2_CortolangEx: ;

}
// $ANTLR end synpred2_Cortolang

// $ANTLR start synpred3_Cortolang
static void synpred3_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:90:5: ( declarationExt )
    // Cortolang.g:90:6: declarationExt
    {
        FOLLOWPUSH(FOLLOW_declarationExt_in_synpred3_Cortolang286);
        declarationExt(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred3_CortolangEx; /* Prevent compiler warnings */
rulesynpred3_CortolangEx: ;

}
// $ANTLR end synpred3_Cortolang

// $ANTLR start synpred4_Cortolang
static void synpred4_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:229:9: ( KW_ELSE )
    // Cortolang.g:229:11: KW_ELSE
    {
         MATCHT(KW_ELSE, &FOLLOW_KW_ELSE_in_synpred4_Cortolang920);
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred4_CortolangEx; /* Prevent compiler warnings */
rulesynpred4_CortolangEx: ;

}
// $ANTLR end synpred4_Cortolang

// $ANTLR start synpred5_Cortolang
static void synpred5_Cortolang_fragment(pCortolangParser ctx )
{
    // Cortolang.g:559:9: ( addOp multExpression )
    // Cortolang.g:559:10: addOp multExpression
    {
        FOLLOWPUSH(FOLLOW_addOp_in_synpred5_Cortolang2420);
        addOp(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred5_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        FOLLOWPUSH(FOLLOW_multExpression_in_synpred5_Cortolang2422);
        multExpression(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred5_CortolangEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred5_CortolangEx; /* Prevent compiler warnings */
rulesynpred5_CortolangEx: ;

}
// $ANTLR end synpred5_Cortolang
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred5_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred5_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred4_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred4_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred3_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred3_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred2_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred2_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred1_Cortolang(pCortolangParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_Cortolang_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
